/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


/** OneOf type helpers */
type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };
type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;
type OneOf<T extends any[]> = T extends [infer Only] ? Only : T extends [infer A, infer B, ...infer Rest] ? OneOf<[XOR<A, B>, ...Rest]> : never;

export interface paths {
  "/auth/exists": {
    /**
     * Check User Exists
     * @description Checks if a user by a given `username`, `displayName` or `email` exist. This is used during registration to check if a username has already been taken, during change of displayName to check if a displayName is available, and during change of email to check if the email is already used. In the later two cases the `excludeUserId` is used to exclude oneself, otherwise the result would always be true.
     *
     * It is **REQUIRED** to include **AT LEAST** `username`, `displayName` **or** `email` query parameter. Although they can be combined - in addition with `excludeUserId` (generally to exclude yourself) - to further fine-tune the search.
     */
    get: operations["checkUserExists"];
  };
  "/auth/user": {
    /**
     * Login and/or Get Current User Info
     * @description This endpoint does the following two operations:
     *   1) Checks if you are already logged in by looking for a valid `auth` cookie. If you are have a valid auth cookie then no additional auth-related actions are taken. If you are **not** logged in then it will log you in with the `Authorization` header and set the `auth` cookie. The `auth` cookie will only be sent once.
     *   2) If logged in, this function will also return the CurrentUser object containing detailed information about the currently logged in user.
     *
     * The auth string after `Authorization: Basic {string}` is a base64-encoded string of the username and password, both individually url-encoded, and then joined with a colon.
     *
     * > base64(urlencode(username):urlencode(password))
     *
     * **WARNING: Session Limit:** Each authentication with login credentials counts as a separate session, out of which you have a limited amount. Make sure to save and reuse the `auth` cookie if you are often restarting the program. The provided API libraries automatically save cookies during runtime, but does not persist during restart. While it can be fine to use username/password during development, expect in production to very fast run into the rate-limit and be temporarily blocked from making new sessions until older ones expire. The exact number of simultaneous sessions is unknown/undisclosed.
     */
    get: operations["getCurrentUser"];
  };
  "/auth/twofactorauth/totp/verify": {
    /**
     * Verify 2FA code
     * @description Finishes the login sequence with a normal 2FA-generated code for accounts with 2FA-protection enabled.
     */
    post: operations["verify2FA"];
  };
  "/auth/twofactorauth/otp/verify": {
    /**
     * Verify 2FA code with Recovery code
     * @description Finishes the login sequence with an OTP (One Time Password) recovery code for accounts with 2FA-protection enabled.
     */
    post: operations["verifyRecoveryCode"];
  };
  "/auth/twofactorauth/emailotp/verify": {
    /**
     * Verify 2FA email code
     * @description Finishes the login sequence with an 2FA email code.
     */
    post: operations["verify2FAEmailCode"];
  };
  "/auth": {
    /**
     * Verify Auth Token
     * @description Verify whether the currently provided Auth Token is valid.
     */
    get: operations["verifyAuthToken"];
  };
  "/logout": {
    /**
     * Logout
     * @description Invalidates the login session.
     */
    put: operations["logout"];
  };
  "/users/{userId}/delete": {
    /**
     * Delete User
     * @description Deletes the account with given ID. Normal users only have permission to delete their own account. Account deletion is 14 days from this request, and will be cancelled if you do an authenticated request with the account afterwards.
     *
     * **VRC+ NOTE:** Despite the 14-days cooldown, any VRC+ subscription will be cancelled **immediately**.
     *
     * **METHOD NOTE:** Despite this being a Delete action, the method type required is PUT.
     */
    put: operations["deleteUser"];
    parameters: {
      path: {
        userId: components["parameters"]["userId"];
      };
    };
  };
  "/users/{userId}/avatar": {
    /**
     * Get Own Avatar
     * @description Get the current avatar for the user. This will return an error for any other user than the one logged in.
     */
    get: operations["getOwnAvatar"];
    parameters: {
      path: {
        userId: components["parameters"]["userId"];
      };
    };
  };
  "/avatars": {
    /**
     * Search Avatars
     * @description Search and list avatars by query filters. You can only search your own or featured avatars. It is not possible as a normal user to search other peoples avatars.
     */
    get: operations["searchAvatars"];
    /**
     * Create Avatar
     * @description Create an avatar. It's possible to optionally specify a ID if you want a custom one. Attempting to create an Avatar with an already claimed ID will result in a DB error.
     */
    post: operations["createAvatar"];
  };
  "/avatars/{avatarId}": {
    /**
     * Get Avatar
     * @description Get information about a specific Avatar.
     */
    get: operations["getAvatar"];
    /**
     * Update Avatar
     * @description Update information about a specific avatar.
     */
    put: operations["updateAvatar"];
    /**
     * Delete Avatar
     * @description Delete an avatar. Notice an avatar is never fully "deleted", only its ReleaseStatus is set to "hidden" and the linked Files are deleted. The AvatarID is permanently reserved.
     */
    delete: operations["deleteAvatar"];
    parameters: {
      path: {
        avatarId: components["parameters"]["avatarId"];
      };
    };
  };
  "/avatars/{avatarId}/select": {
    /**
     * Select Avatar
     * @description Switches into that avatar.
     */
    put: operations["selectAvatar"];
    parameters: {
      path: {
        avatarId: components["parameters"]["avatarId"];
      };
    };
  };
  "/avatars/{avatarId}/selectFallback": {
    /**
     * Select Fallback Avatar
     * @description Switches into that avatar as your fallback avatar.
     */
    put: operations["selectFallbackAvatar"];
    parameters: {
      path: {
        avatarId: components["parameters"]["avatarId"];
      };
    };
  };
  "/avatars/favorites": {
    /**
     * List Favorited Avatars
     * @description Search and list favorited avatars by query filters.
     */
    get: operations["getFavoritedAvatars"];
  };
  "/Steam/transactions": {
    /**
     * List Steam Transactions
     * @description Get all own Steam transactions.
     */
    get: operations["getSteamTransactions"];
  };
  "/Steam/transactions/{transactionId}": {
    /**
     * Get Steam Transaction
     * @deprecated
     * @description Get a single Steam transactions by ID. This returns the exact same information as `getSteamTransactions`, so no point in using this endpoint.
     */
    get: operations["getSteamTransaction"];
    parameters: {
      path: {
        transactionId: components["parameters"]["transactionId"];
      };
    };
  };
  "/Admin/transactions/{transactionId}": {
    parameters: {
      path: {
        transactionId: components["parameters"]["transactionId"];
      };
    };
  };
  "/auth/user/subscription": {
    /**
     * Get Current Subscriptions
     * @description Get a list of all current user subscriptions.
     */
    get: operations["getCurrentSubscriptions"];
  };
  "/subscriptions": {
    /**
     * List Subscriptions
     * @description List all existing Subscriptions. For example, "vrchatplus-monthly" and "vrchatplus-yearly".
     */
    get: operations["getSubscriptions"];
  };
  "/licenseGroups/{licenseGroupId}": {
    /**
     * Get License Group
     * @description Get a single License Group by given ID.
     */
    get: operations["getLicenseGroup"];
    parameters: {
      path: {
        licenseGroupId: components["parameters"]["licenseGroupId"];
      };
    };
  };
  "/favorites": {
    /**
     * List Favorites
     * @description Returns a list of favorites.
     */
    get: operations["getFavorites"];
    /**
     * Add Favorite
     * @description Add a new favorite.
     *
     * Friend groups are named `group_0` through `group_3`. Avatar and World groups are named `avatars1` to `avatars4` and `worlds1` to `worlds4`.
     *
     * You cannot add people whom you are not friends with to your friends list. Destroying a friendship removes the person as favorite on both sides.
     */
    post: operations["addFavorite"];
  };
  "/favorites/{favoriteId}": {
    /**
     * Show Favorite
     * @description Return information about a specific Favorite.
     */
    get: operations["getFavorite"];
    /**
     * Remove Favorite
     * @description Remove a favorite from your favorites list.
     */
    delete: operations["removeFavorite"];
    parameters: {
      path: {
        favoriteId: components["parameters"]["favoriteId"];
      };
    };
  };
  "/favorite/groups": {
    /**
     * List Favorite Groups
     * @description Return a list of favorite groups owned by a user. Returns the same information as `getFavoriteGroups`.
     */
    get: operations["getFavoriteGroups"];
  };
  "/favorite/group/{favoriteGroupType}/{favoriteGroupName}/{userId}": {
    /**
     * Show Favorite Group
     * @description Fetch information about a specific favorite group.
     */
    get: operations["getFavoriteGroup"];
    /**
     * Update Favorite Group
     * @description Update information about a specific favorite group.
     */
    put: operations["updateFavoriteGroup"];
    /**
     * Clear Favorite Group
     * @description Clear ALL contents of a specific favorite group.
     */
    delete: operations["clearFavoriteGroup"];
    parameters: {
      path: {
        favoriteGroupType: components["parameters"]["favoriteGroupType"];
        favoriteGroupName: components["parameters"]["favoriteGroupName"];
        userId: components["parameters"]["userId"];
      };
    };
  };
  "/files": {
    /**
     * List Files
     * @description Returns a list of files
     */
    get: operations["getFiles"];
  };
  "/file": {
    /**
     * Create File
     * @description Creates a new File object
     */
    post: operations["createFile"];
  };
  "/file/{fileId}": {
    /**
     * Show File
     * @description Shows general information about the "File" object. Each File can have several "Version"'s, and each Version can have multiple real files or "Data" blobs.
     */
    get: operations["getFile"];
    /**
     * Create File Version
     * @description Creates a new FileVersion. Once a Version has been created, proceed to the `/file/{fileId}/{versionId}/file/start` endpoint to start a file upload.
     */
    post: operations["createFileVersion"];
    /**
     * Delete File
     * @description Deletes a File object.
     */
    delete: operations["deleteFile"];
    parameters: {
      path: {
        fileId: components["parameters"]["fileId"];
      };
    };
  };
  "/file/{fileId}/{versionId}": {
    /**
     * Download File Version
     * @description Downloads the file with the provided version number.
     *
     * **Version Note:** Version 0 is always when the file was created. The real data is usually always located in version 1 and up.
     *
     * **Extension Note:** Files are not guaranteed to have a file extensions. UnityPackage files tends to have it, images through this endpoint do not. You are responsible for appending file extension from the `extension` field when neccesary.
     */
    get: operations["downloadFileVersion"];
    /**
     * Delete File Version
     * @description Delete a specific version of a file. You can only delete the latest version.
     */
    delete: operations["deleteFileVersion"];
    parameters: {
      path: {
        fileId: components["parameters"]["fileId"];
        versionId: components["parameters"]["versionId"];
      };
    };
  };
  "/file/{fileId}/{versionId}/{fileType}/finish": {
    /**
     * Finish FileData Upload
     * @description Finish an upload of a FileData. This will mark it as "complete". After uploading the `file` for Avatars and Worlds you then have to upload a `signature` file.
     */
    put: operations["finishFileDataUpload"];
    parameters: {
      path: {
        fileId: components["parameters"]["fileId"];
        versionId: components["parameters"]["versionId"];
        fileType: components["parameters"]["fileType"];
      };
    };
  };
  "/file/{fileId}/{versionId}/{fileType}/start": {
    /**
     * Start FileData Upload
     * @description Starts an upload of a specific FilePart. This endpoint will return an AWS URL which you can PUT data to. You need to call this and receive a new AWS API URL for each `partNumber`. Please see AWS's REST documentation on "PUT Object to S3" on how to upload. Once all parts has been uploaded, proceed to `/finish` endpoint.
     *
     * **Note:** `nextPartNumber` seems like it is always ignored. Despite it returning 0, first partNumber is always 1.
     */
    put: operations["startFileDataUpload"];
    parameters: {
      path: {
        fileId: components["parameters"]["fileId"];
        versionId: components["parameters"]["versionId"];
        fileType: components["parameters"]["fileType"];
      };
    };
  };
  "/file/{fileId}/{versionId}/{fileType}/status": {
    /**
     * Check FileData Upload Status
     * @description Retrieves the upload status for file upload. Can currently only be accessed when `status` is `waiting`. Trying to access it on a file version already uploaded currently times out.
     */
    get: operations["getFileDataUploadStatus"];
    parameters: {
      path: {
        fileId: components["parameters"]["fileId"];
        versionId: components["parameters"]["versionId"];
        fileType: components["parameters"]["fileType"];
      };
    };
  };
  "/auth/user/friends": {
    /**
     * List Friends
     * @description List information about friends.
     */
    get: operations["getFriends"];
  };
  "/user/{userId}/friendRequest": {
    /**
     * Send Friend Request
     * @description Send a friend request to another user.
     */
    post: operations["friend"];
    /**
     * Delete Friend Request
     * @description Deletes an outgoing pending friend request to another user. To delete an incoming friend request, use the `deleteNotification` endpoint instead.
     */
    delete: operations["deleteFriendRequest"];
    parameters: {
      path: {
        userId: components["parameters"]["userId"];
      };
    };
  };
  "/user/{userId}/friendStatus": {
    /**
     * Check Friend Status
     * @description Retrieve if the user is currently a friend with a given user, if they have an outgoing friend request, and if they have an incoming friend request. The proper way to receive and accept friend request is by checking if the user has an incoming `Notification` of type `friendRequest`, and then accepting that notification.
     */
    get: operations["getFriendStatus"];
    parameters: {
      path: {
        userId: components["parameters"]["userId"];
      };
    };
  };
  "/auth/user/friends/{userId}": {
    /**
     * Unfriend
     * @description Unfriend a user by ID.
     */
    delete: operations["unfriend"];
    parameters: {
      path: {
        userId: components["parameters"]["userId"];
      };
    };
  };
  "/groups": {
    /**
     * Create Group
     * @description Creates a Group and returns a Group object. **Requires VRC+ Subscription.**
     */
    post: operations["createGroup"];
  };
  "/groups/{groupId}": {
    /**
     * Get Group by ID
     * @description Returns a single Group by ID.
     */
    get: operations["getGroup"];
    /**
     * Update Group
     * @description Updates a Group and returns it.
     */
    put: operations["updateGroup"];
    /**
     * Delete Group
     * @description Deletes a Group.
     */
    delete: operations["deleteGroup"];
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
      };
    };
  };
  "/groups/{groupId}/announcement": {
    /**
     * Get Group Announcement
     * @description Returns the announcement for a Group.
     * If no announcement has been made, then it returns **empty object**.
     * If an announcement exists, then it will always return all fields except `imageId` and `imageUrl` which may be null.
     */
    get: operations["getGroupAnnouncements"];
    /**
     * Create Group Announcement
     * @description Creates an Announcement for a Group.
     */
    post: operations["createGroupAnnouncement"];
    /**
     * Delete Group Announcement
     * @description Deletes the announcement for a Group.
     */
    delete: operations["deleteGroupAnnouncement"];
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
      };
    };
  };
  "/groups/{groupId}/auditLogs": {
    /**
     * Get Group Audit Logs
     * @description Returns a list of audit logs for a Group.
     */
    get: operations["getGroupAuditLogs"];
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
      };
    };
  };
  "/groups/{groupId}/bans": {
    /**
     * Get Group Bans
     * @description Returns a list of banned users for a Group.
     */
    get: operations["getGroupBans"];
    /**
     * Ban Group Member
     * @description Bans a user from a Group.
     */
    post: operations["banGroupMember"];
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
      };
    };
  };
  "/groups/{groupId}/bans/{userId}": {
    /**
     * Unban Group Member
     * @description Unbans a user from a Group.
     */
    delete: operations["unbanGroupMember"];
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
        userId: components["parameters"]["userId"];
      };
    };
  };
  "/groups/{groupId}/galleries": {
    /**
     * Create Group Gallery
     * @description Creates a gallery for a Group.
     */
    post: operations["createGroupGallery"];
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
      };
    };
  };
  "/groups/{groupId}/galleries/{groupGalleryId}": {
    /**
     * Get Group Gallery Images
     * @description Returns a list of images for a Group gallery.
     */
    get: operations["getGroupGalleryImages"];
    /**
     * Update Group Gallery
     * @description Updates a gallery for a Group.
     */
    put: operations["updateGroupGallery"];
    /**
     * Delete Group Gallery
     * @description Deletes a gallery for a Group.
     */
    delete: operations["deleteGroupGallery"];
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
        groupGalleryId: components["parameters"]["groupGalleryId"];
      };
    };
  };
  "/groups/{groupId}/galleries/{groupGalleryId}/images": {
    /**
     * Add Group Gallery Image
     * @description Adds an image to a Group gallery.
     */
    post: operations["addGroupGalleryImage"];
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
        groupGalleryId: components["parameters"]["groupGalleryId"];
      };
    };
  };
  "/groups/{groupId}/galleries/{groupGalleryId}/images/{groupGalleryImageId}": {
    /**
     * Delete Group Gallery Image
     * @description Deletes an image from a Group gallery.
     */
    delete: operations["deleteGroupGalleryImage"];
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
        groupGalleryId: components["parameters"]["groupGalleryId"];
        groupGalleryImageId: components["parameters"]["groupGalleryImageId"];
      };
    };
  };
  "/groups/{groupId}/invites": {
    /**
     * Get Group Invites Sent
     * @description Returns a list of members that have been invited to the Group.
     */
    get: operations["getGroupInvites"];
    /**
     * Invite User to Group
     * @description Sends an invite to a user to join the group.
     */
    post: operations["createGroupInvite"];
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
      };
    };
  };
  "/groups/{groupId}/invites/{userId}": {
    /**
     * Delete User Invite
     * @description Deletes an Group invite sent to a User
     */
    delete: operations["deleteGroupInvite"];
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
        userId: components["parameters"]["userId"];
      };
    };
  };
  "/groups/{groupId}/join": {
    /**
     * Join Group
     * @description Join a Group by ID and returns the member object.
     */
    post: operations["joinGroup"];
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
      };
    };
  };
  "/groups/{groupId}/leave": {
    /**
     * Leave Group
     * @description Leave a group by ID.
     */
    post: operations["leaveGroup"];
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
      };
    };
  };
  "/groups/{groupId}/members": {
    /**
     * List Group Members
     * @description Returns a List of all **other** Group Members. This endpoint will never return the user calling the endpoint.
     * Information about the user calling the endpoint must be found in the `myMember` field of the Group object.
     */
    get: operations["getGroupMembers"];
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
      };
    };
  };
  "/groups/{groupId}/members/{userId}": {
    /**
     * Get Group Member
     * @description Returns a LimitedGroup Member.
     */
    get: operations["getGroupMember"];
    /**
     * Update Group Member
     * @description Updates a Group Member
     */
    put: operations["updateGroupMember"];
    /**
     * Kick Group Member
     * @description Kicks a Group Member from the Group. The current user must have the "Remove Group Members" permission.
     */
    delete: operations["kickGroupMember"];
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
        userId: components["parameters"]["userId"];
      };
    };
  };
  "/groups/{groupId}/members/{userId}/roles/{groupRoleId}": {
    /**
     * Add Role to GroupMember
     * @description Adds a Role to a Group Member
     */
    put: operations["addGroupMemberRole"];
    /**
     * Remove Role from GroupMember
     * @description Removes a Role from a Group Member
     */
    delete: operations["removeGroupMemberRole"];
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
        userId: components["parameters"]["userId"];
        groupRoleId: components["parameters"]["groupRoleId"];
      };
    };
  };
  "/groups/{groupId}/permissions": {
    /**
     * List Group Permissions
     * @description Returns a List of all possible/available permissions for a Group.
     */
    get: operations["getGroupPermissions"];
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
      };
    };
  };
  "/groups/{groupId}/requests": {
    /**
     * Get Group Join Requests
     * @description Returns a list of members that have requested to join the Group.
     */
    get: operations["getGroupRequests"];
    /**
     * Cancel Group Join Request
     * @description Cancels a request sent to join the group.
     */
    delete: operations["cancelGroupRequest"];
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
      };
    };
  };
  "/groups/{groupId}/requests/{userId}": {
    /**
     * Respond Group Join request
     * @description Responds to a Group Join Request with Accept/Deny
     */
    put: operations["respondGroupJoinRequest"];
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
        userId: components["parameters"]["userId"];
      };
    };
  };
  "/groups/{groupId}/roles": {
    /**
     * Get Group Roles
     * @description Returns a Group Role by ID.
     */
    get: operations["getGroupRoles"];
    /**
     * Create GroupRole
     * @description Create a Group role.
     */
    post: operations["createGroupRole"];
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
      };
    };
  };
  "/groups/{groupId}/roles/{groupRoleId}": {
    /**
     * Update Group Role
     * @description Updates a group role by ID.
     */
    put: operations["updateGroupRole"];
    /**
     * Delete Group Role
     * @description Deletes a Group Role by ID and returns the remaining roles.
     */
    delete: operations["deleteGroupRole"];
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
        groupRoleId: components["parameters"]["groupRoleId"];
      };
    };
  };
  "/invite/{userId}": {
    /**
     * Invite User
     * @description Sends an invite to a user. Returns the Notification of type `invite` that was sent.
     */
    post: operations["inviteUser"];
    parameters: {
      path: {
        userId: components["parameters"]["userId"];
      };
    };
  };
  "/invite/myself/to/{worldId}:{instanceId}": {
    /**
     * Invite Myself To Instance
     * @description Sends self an invite to an instance
     */
    post: operations["inviteMyselfTo"];
    parameters: {
      path: {
        worldId: components["parameters"]["worldId"];
        instanceId: components["parameters"]["instanceId"];
      };
    };
  };
  "/requestInvite/{userId}": {
    /**
     * Request Invite
     * @description Requests an invite from a user. Returns the Notification of type `requestInvite` that was sent.
     */
    post: operations["requestInvite"];
    parameters: {
      path: {
        userId: components["parameters"]["userId"];
      };
    };
  };
  "/invite/{notificationId}/response": {
    /**
     * Respond Invite
     * @description Respond to an invite request by sending a world invite to the requesting user. `:notificationId` is the ID of the requesting notification.
     */
    post: operations["respondInvite"];
    parameters: {
      path: {
        notificationId: components["parameters"]["notificationId"];
      };
    };
  };
  "/message/{userId}/{messageType}": {
    /**
     * List Invite Messages
     * @description Returns a list of all the users Invite Messages. Admin Credentials are required to view messages of other users!
     *
     * Message type refers to a different collection of messages, used during different types of responses.
     *
     * * `message` = Message during a normal invite
     * * `response` = Message when replying to a message
     * * `request` = Message when requesting an invite
     * * `requestResponse` = Message when replying to a request for invite
     */
    get: operations["getInviteMessages"];
    parameters: {
      path: {
        userId: components["parameters"]["userId"];
        messageType: components["parameters"]["messageType"];
      };
    };
  };
  "/message/{userId}/{messageType}/{slot}": {
    /**
     * Get Invite Message
     * @description Returns a single Invite Message. This returns the exact same information but less than `getInviteMessages`. Admin Credentials are required to view messages of other users!
     *
     * Message type refers to a different collection of messages, used during different types of responses.
     *
     * * `message` = Message during a normal invite
     * * `response` = Message when replying to a message
     * * `request` = Message when requesting an invite
     * * `requestResponse` = Message when replying to a request for invite
     */
    get: operations["getInviteMessage"];
    /**
     * Update Invite Message
     * @description Updates a single Invite Message and then returns a list of all of them. Admin Credentials are required to update messages of other users!
     *
     * Updating a message automatically sets the cooldown timer to 60 minutes.
     * Trying to edit a message before the cooldown timer expires results in a 429 "Too Fast Error".
     *
     * Message type refers to a different collection of messages, used during different types of responses.
     *
     * * `message` = Message during a normal invite
     * * `response` = Message when replying to a message
     * * `request` = Message when requesting an invite
     * * `requestResponse` = Message when replying to a request for invite
     */
    put: operations["updateInviteMessage"];
    /**
     * Reset Invite Message
     * @description Resets a single Invite Message back to its original message, and then returns a list of all of them. Admin Credentials are required to update messages of other users!
     *
     * Resetting a message respects the rate-limit, so it is not possible to reset within the 60 minutes countdown.
     * Resetting it does however not set the rate-limit to 60 like when editing it.
     * It is possible to edit it right after resetting it.
     * Trying to edit a message before the cooldown timer expires results in a 429 "Too Fast Error".
     *
     * Message type refers to a different collection of messages, used during different types of responses.
     *
     * * `message` = Message during a normal invite
     * * `response` = Message when replying to a message
     * * `request` = Message when requesting an invite
     * * `requestResponse` = Message when replying to a request for invite
     *
     * The DELETE endpoint does not have/require any request body.
     */
    delete: operations["resetInviteMessage"];
    parameters: {
      path: {
        userId: components["parameters"]["userId"];
        messageType: components["parameters"]["messageType"];
        slot: components["parameters"]["slot"];
      };
    };
  };
  "/instances/{worldId}:{instanceId}": {
    /**
     * Get Instance
     * @description Returns an instance. Please read [Instances Tutorial](https://vrchatapi.github.io/tutorials/instances/) for more information on Instances.
     *
     * If an invalid instanceId is provided, this endpoint will simply return "null"!
     */
    get: operations["getInstance"];
    parameters: {
      path: {
        worldId: components["parameters"]["worldId"];
        instanceId: components["parameters"]["instanceId"];
      };
    };
  };
  "/instances/{worldId}:{instanceId}/shortName": {
    /**
     * Get Instance Short Name
     * @description Returns an instance short name.
     */
    get: operations["getShortName"];
    parameters: {
      path: {
        worldId: components["parameters"]["worldId"];
        instanceId: components["parameters"]["instanceId"];
      };
    };
  };
  "/instances/{worldId}:{instanceId}/invite": {
    /**
     * Send Self Invite
     * @description Sends an invite to the instance to yourself.
     */
    post: operations["sendSelfInvite"];
    parameters: {
      path: {
        worldId: components["parameters"]["worldId"];
        instanceId: components["parameters"]["instanceId"];
      };
    };
  };
  "/instances/s/{shortName}": {
    /**
     * Get Instance By Short Name
     * @description Returns an instance. Please read [Instances Tutorial](https://vrchatapi.github.io/tutorials/instances/) for more information on Instances.
     */
    get: operations["getInstanceByShortName"];
    parameters: {
      path: {
        /** @description Must be a valid instance short name. */
        shortName: string;
      };
    };
  };
  "/auth/user/notifications": {
    /**
     * List Notifications
     * @description Retrieve all of the current user's notifications.
     */
    get: operations["getNotifications"];
  };
  "/auth/user/notifications/{notificationId}/accept": {
    /**
     * Accept Friend Request
     * @description Accept a friend request by notification `frq_` ID. Friend requests can be found using the NotificationsAPI `getNotifications` by filtering of type `friendRequest`.
     */
    put: operations["acceptFriendRequest"];
    parameters: {
      path: {
        notificationId: components["parameters"]["notificationId"];
      };
    };
  };
  "/auth/user/notifications/{notificationId}/see": {
    /**
     * Mark Notification As Read
     * @description Mark a notification as seen.
     */
    put: operations["markNotificationAsRead"];
    parameters: {
      path: {
        notificationId: components["parameters"]["notificationId"];
      };
    };
  };
  "/auth/user/notifications/{notificationId}/hide": {
    /**
     * Delete Notification
     * @description Delete a notification.
     */
    put: operations["deleteNotification"];
    parameters: {
      path: {
        notificationId: components["parameters"]["notificationId"];
      };
    };
  };
  "/auth/user/notifications/clear": {
    /**
     * Clear All Notifications
     * @description Clear **all** notifications.
     */
    put: operations["clearNotifications"];
  };
  "/auth/permissions": {
    /**
     * Get Assigned Permissions
     * @description Returns a list of all permissions currently granted by the user. Permissions are assigned e.g. by subscribing to VRC+.
     */
    get: operations["getAssignedPermissions"];
  };
  "/permissions/{permissionId}": {
    /**
     * Get Permission
     * @description Returns a single permission. This endpoint is pretty useless, as it returns the exact same information as `/auth/permissions`.
     */
    get: operations["getPermission"];
    parameters: {
      path: {
        permissionId: components["parameters"]["permissionId"];
      };
    };
  };
  "/auth/user/playermoderations": {
    /**
     * Search Player Moderations
     * @description Returns a list of all player moderations made by **you**.
     *
     * This endpoint does not have pagination, and will return *all* results. Use query parameters to limit your query if needed.
     */
    get: operations["getPlayerModerations"];
    /**
     * Moderate User
     * @description Moderate a user, e.g. unmute them or show their avatar.
     *
     * Please see the [Player Moderation docs](https://vrchatapi.github.io/docs/api/#tag--playermoderation) on what playerModerations are, and how they differ from staff moderations.
     */
    post: operations["moderateUser"];
    /**
     * Clear All Player Moderations
     * @description ⚠️ **This will delete every single player moderation you've ever made.**
     */
    delete: operations["clearAllPlayerModerations"];
  };
  "/auth/user/playermoderations/{playerModerationId}": {
    /**
     * Get Player Moderation
     * @description Returns a single Player Moderation. This returns the exact same amount of information as the more generalised `getPlayerModerations`.
     */
    get: operations["getPlayerModeration"];
    /**
     * Delete Player Moderation
     * @description Deletes a specific player moderation based on it's `pmod_` ID. The website uses `unmoderateUser` instead. You can delete the same player moderation multiple times successfully.
     */
    delete: operations["deletePlayerModeration"];
    parameters: {
      path: {
        /** @description Must be a valid `pmod_` ID. */
        playerModerationId: string;
      };
    };
  };
  "/auth/user/unplayermoderate": {
    /**
     * Unmoderate User
     * @description Removes a player moderation previously added through `moderateUser`. E.g if you previously have shown their avatar, but now want to reset it to default.
     */
    put: operations["unmoderateUser"];
  };
  "/config": {
    /**
     * Fetch API Config
     * @description API config contains configuration that the clients needs to work properly.
     *
     * Currently the most important value here is `clientApiKey` which is used for all other API endpoints.
     */
    get: operations["getConfig"];
  };
  "/infoPush": {
    /**
     * Show Information Notices
     * @description IPS (Info Push System) is a system for VRChat to push out dynamic information to the client. This is primarily used by the Quick-Menu info banners, but can also be used to e.g. alert you to update your game to the latest version.
     *
     * `include` is used to query what Information Pushes should be included in the response. If include is missing or empty, then no notices will normally be returned. This is an "any of" search.
     *
     * `require` is used to limit what Information Pushes should be included in the response. This is usually used in combination with `include`, and is an "all of" search.
     */
    get: operations["getInfoPush"];
  };
  "/css/app.css": {
    /**
     * Download CSS
     * @description Fetches the CSS code to the frontend React website.
     */
    get: operations["getCSS"];
  };
  "/js/app.js": {
    /**
     * Download JavaScript
     * @description Fetches the JavaScript code to the frontend React website.
     */
    get: operations["getJavaScript"];
  };
  "/health": {
    /**
     * Check API Health
     * @deprecated
     * @description ~~Gets the overall health status, the server name, and the current build version tag of the API.~~
     *
     * **DEPRECATED:** VRChat has suddenly restricted this endpoint for unknown reasons, and now always return 401 Unauthorized.
     */
    get: operations["getHealth"];
  };
  "/visits": {
    /**
     * Current Online Users
     * @description Returns the current number of online users.
     *
     * **NOTE:** The response type is not a JSON object, but a simple JSON integer.
     */
    get: operations["getCurrentOnlineUsers"];
  };
  "/time": {
    /**
     * Current System Time
     * @description Returns the current time of the API server.
     *
     * **NOTE:** The response type is not a JSON object, but a simple JSON string.
     */
    get: operations["getSystemTime"];
  };
  "/users": {
    /**
     * Search All Users
     * @description Search and list any users by text query
     */
    get: operations["searchUsers"];
  };
  "/users/{username}/name": {
    /**
     * Get User by Username
     * @deprecated
     * @description ~~Get public user information about a specific user using their name.~~
     *
     * **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429).
     * This endpoint now require Admin Credentials.
     */
    get: operations["getUserByName"];
    parameters: {
      path: {
        /** @description Username of the user */
        username: string;
      };
    };
  };
  "/users/{userId}": {
    /**
     * Get User by ID
     * @description Get public user information about a specific user using their ID.
     */
    get: operations["getUser"];
    /**
     * Update User Info
     * @description Update a users information such as the email and birthday.
     */
    put: operations["updateUser"];
    parameters: {
      path: {
        userId: components["parameters"]["userId"];
      };
    };
  };
  "/users/{userId}/groups": {
    /**
     * Get User Groups
     * @description Get user's public groups
     */
    get: operations["getUserGroups"];
    parameters: {
      path: {
        userId: components["parameters"]["userId"];
      };
    };
  };
  "/users/{userId}/groups/requested": {
    /**
     * Get User Group Requests
     * @description Returns a list of Groups the user has requested to be invited into.
     */
    get: operations["getUserGroupRequests"];
    parameters: {
      path: {
        userId: components["parameters"]["userId"];
      };
    };
  };
  "/worlds": {
    /**
     * Search All Worlds
     * @description Search and list any worlds by query filters.
     */
    get: operations["searchWorlds"];
    /**
     * Create World
     * @description Create a new world. This endpoint requires `assetUrl` to be a valid File object with `.vrcw` file extension, and `imageUrl` to be a valid File object with an image file extension.
     */
    post: operations["createWorld"];
  };
  "/worlds/active": {
    /**
     * List Active Worlds
     * @description Search and list currently Active worlds by query filters.
     */
    get: operations["getActiveWorlds"];
  };
  "/worlds/favorites": {
    /**
     * List Favorited Worlds
     * @description Search and list favorited worlds by query filters.
     */
    get: operations["getFavoritedWorlds"];
  };
  "/worlds/recent": {
    /**
     * List Recent Worlds
     * @description Search and list recently visited worlds by query filters.
     */
    get: operations["getRecentWorlds"];
  };
  "/worlds/{worldId}": {
    /**
     * Get World by ID
     * @description Get information about a specific World.
     * Works unauthenticated but when so will always return `0` for certain fields.
     */
    get: operations["getWorld"];
    /**
     * Update World
     * @description Update information about a specific World.
     */
    put: operations["updateWorld"];
    /**
     * Delete World
     * @description Delete a world. Notice a world is never fully "deleted", only its ReleaseStatus is set to "hidden" and the linked Files are deleted. The WorldID is permanently reserved.
     */
    delete: operations["deleteWorld"];
    parameters: {
      path: {
        worldId: components["parameters"]["worldId"];
      };
    };
  };
  "/worlds/{worldId}/metadata": {
    /**
     * Get World Metadata
     * @deprecated
     * @description Return a worlds custom metadata. This is currently believed to be unused. Metadata can be set with `updateWorld` and can be any arbitrary object.
     */
    get: operations["getWorldMetadata"];
    parameters: {
      path: {
        worldId: components["parameters"]["worldId"];
      };
    };
  };
  "/worlds/{worldId}/publish": {
    /**
     * Get World Publish Status
     * @description Returns a worlds publish status.
     */
    get: operations["getWorldPublishStatus"];
    /**
     * Publish World
     * @description Publish a world. You can only publish one world per week.
     */
    put: operations["publishWorld"];
    /**
     * Unpublish World
     * @description Unpublish a world.
     */
    delete: operations["unpublishWorld"];
    parameters: {
      path: {
        worldId: components["parameters"]["worldId"];
      };
    };
  };
  "/worlds/{worldId}/{instanceId}": {
    /**
     * Get World Instance
     * @description Returns a worlds instance.
     */
    get: operations["getWorldInstance"];
    parameters: {
      path: {
        worldId: components["parameters"]["worldId"];
        instanceId: components["parameters"]["instanceId"];
      };
    };
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    /**
     * UserExists
     * @description Status object representing if a queried user by username or userId exists or not. This model is primarily used by the `/auth/exists` endpoint, which in turn is used during registration. Please see the documentation on that endpoint for more information on usage.
     */
    UserExists: {
      /**
       * @description Status if a user exist with that username or userId.
       * @default false
       */
      userExists: boolean;
    };
    /** Response */
    Response: {
      message?: string;
      status_code: number;
    };
    /** Error */
    Error: {
      error?: components["schemas"]["Response"];
    };
    /** AccountDeletionLog */
    AccountDeletionLog: {
      /**
       * @description Typically "Deletion requested" or "Deletion canceled". Other messages like "Deletion completed" may exist, but are these are not possible to see as a regular user.
       * @default Deletion requested
       * @example Deletion requested
       */
      message?: string;
      /**
       * Format: date-time
       * @description When the deletion is scheduled to happen, standard is 14 days after the request.
       */
      deletionScheduled?: string | null;
      /**
       * Format: date-time
       * @description Date and time of the deletion request.
       */
      dateTime?: string;
    };
    /**
     * UserID
     * @description A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @example usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469
     */
    UserID: string;
    /**
     * AvatarID
     * @example avtr_912d66a4-4714-43b8-8407-7de2cafbf55b
     */
    AvatarID: string;
    /**
     * CurrentAvatarImageUrl
     * @description When profilePicOverride is not empty, use it instead.
     * @example https://api.vrchat.cloud/api/1/file/file_ae46d521-7281-4b38-b365-804b32a1d6a7/1/file
     */
    CurrentAvatarImageUrl: string;
    /**
     * CurrentAvatarThumbnailImageUrl
     * @description When profilePicOverride is not empty, use it instead.
     * @example https://api.vrchat.cloud/api/1/image/file_aae83ed9-d42d-4d72-9f4b-9f1e41ed17e1/1/256
     */
    CurrentAvatarThumbnailImageUrl: string;
    /**
     * DeveloperType
     * @description "none" User is a normal user
     * "trusted" Unknown
     * "internal" Is a VRChat Developer
     * "moderator" Is a VRChat Moderator
     *
     * Staff can hide their developerType at will.
     * @default none
     * @enum {string}
     */
    DeveloperType: "none" | "trusted" | "internal" | "moderator";
    /**
     * WorldID
     * @description WorldID be "offline" on User profiles if you are not friends with that user.
     * @example wrld_ba913a96-fac4-4048-a062-9aa5db092812
     */
    WorldID: string;
    /**
     * Platform
     * @description This can be `standalonewindows` or `android`, but can also pretty much be any random Unity verison such as `2019.2.4-801-Release` or `2019.2.2-772-Release` or even `unknownplatform`.
     * @example standalonewindows
     */
    Platform: string;
    /** PastDisplayName */
    PastDisplayName: {
      displayName: string;
      /** Format: date-time */
      updated_at: string;
    };
    /**
     * GroupID
     * @example grp_71a7ff59-112c-4e78-a990-c7cc650776e5
     */
    GroupID: string;
    /** CurrentUserPresence */
    CurrentUserPresence: {
      avatarThumbnail?: string | null;
      displayName?: string;
      groups?: components["schemas"]["GroupID"][] | null;
      id?: components["schemas"]["UserID"];
      instance?: string | null;
      /** @description either an InstanceType or an empty string */
      instanceType?: string | null;
      isRejoining?: string | null;
      /** @description either a Platform or an empty string */
      platform?: string | null;
      profilePicOverride?: string | null;
      /** @description either a UserStatus or empty string */
      status?: string | null;
      travelingToInstance?: string | null;
      travelingToWorld?: components["schemas"]["WorldID"];
      world?: components["schemas"]["WorldID"];
    };
    /**
     * UserState
     * @description * "online" User is online in VRChat
     * * "active" User is online, but not in VRChat
     * * "offline" User is offline
     *
     * Always offline when returned through `getCurrentUser` (/auth/user).
     * @default offline
     * @enum {string}
     */
    UserState: "offline" | "active" | "online";
    /**
     * UserStatus
     * @description Defines the User's current status, for example "ask me", "join me" or "offline. This status is a combined indicator of their online activity and privacy preference.
     * @default offline
     * @enum {string}
     */
    UserStatus: "active" | "join me" | "ask me" | "busy" | "offline";
    /**
     * Tag
     * @description Tags are a way to grant various access, assign restrictions or other kinds of metadata to various to objects such as worlds, users and avatars.
     *
     * System tags starting with `system_` are granted automatically by the system, while admin tags with `admin_` are granted manually. More prefixes such as `language_ ` (to indicate that a player can speak the tagged language), and `author_tag_` (provided by a world author for search and sorting) exist as well.
     */
    Tag: string;
    /** CurrentUser */
    CurrentUser: {
      /** @example 7 */
      acceptedTOSVersion: number;
      /** @example 0 */
      acceptedPrivacyVersion?: number;
      /** Format: date */
      accountDeletionDate?: string | null;
      /** @description */
      accountDeletionLog?: components["schemas"]["AccountDeletionLog"][] | null;
      /** @description */
      activeFriends?: components["schemas"]["UserID"][];
      allowAvatarCopying: boolean;
      bio: string;
      /** @description */
      bioLinks: string[];
      currentAvatar: components["schemas"]["AvatarID"];
      currentAvatarAssetUrl: string;
      currentAvatarImageUrl: components["schemas"]["CurrentAvatarImageUrl"];
      currentAvatarThumbnailImageUrl: components["schemas"]["CurrentAvatarThumbnailImageUrl"];
      /** Format: date */
      date_joined: string;
      developerType: components["schemas"]["DeveloperType"];
      displayName: string;
      emailVerified: boolean;
      fallbackAvatar?: components["schemas"]["AvatarID"];
      /**
       * @deprecated
       * @description Always empty array.
       */
      friendGroupNames: string[];
      friendKey: string;
      friends: components["schemas"]["UserID"][];
      hasBirthday: boolean;
      hasEmail: boolean;
      hasLoggedInFromClient: boolean;
      hasPendingEmail: boolean;
      homeLocation: components["schemas"]["WorldID"];
      id: components["schemas"]["UserID"];
      /** @default false */
      isFriend: boolean;
      /** Format: date-time */
      last_activity?: string;
      /** Format: date-time */
      last_login: string;
      last_platform: components["schemas"]["Platform"];
      obfuscatedEmail: string;
      obfuscatedPendingEmail: string;
      oculusId: string;
      offlineFriends?: components["schemas"]["UserID"][];
      onlineFriends?: components["schemas"]["UserID"][];
      /** @description */
      pastDisplayNames: components["schemas"]["PastDisplayName"][];
      presence?: components["schemas"]["CurrentUserPresence"];
      profilePicOverride: string;
      state: components["schemas"]["UserState"];
      status: components["schemas"]["UserStatus"];
      statusDescription: string;
      statusFirstTime: boolean;
      statusHistory: string[];
      steamDetails: Record<string, never>;
      steamId: string;
      tags: components["schemas"]["Tag"][];
      twoFactorAuthEnabled: boolean;
      /** Format: date-time */
      twoFactorAuthEnabledDate?: string | null;
      unsubscribe: boolean;
      /** Format: date-time */
      updated_at?: string;
      userIcon: string;
      /**
       * @deprecated
       * @description -| **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429).
       */
      username?: string;
    };
    /** TwoFactorAuthCode */
    TwoFactorAuthCode: {
      code: string;
    };
    /** Verify2FAResult */
    Verify2FAResult: {
      verified: boolean;
    };
    /** TwoFactorEmailCode */
    TwoFactorEmailCode: {
      code: string;
    };
    /** Verify2FAEmailCodeResult */
    Verify2FAEmailCodeResult: {
      verified: boolean;
    };
    /** VerifyAuthTokenResult */
    VerifyAuthTokenResult: {
      ok: boolean;
      token: string;
    };
    /** Success */
    Success: {
      success?: components["schemas"]["Response"];
    };
    /**
     * ReleaseStatus
     * @default public
     * @example public
     * @enum {string}
     */
    ReleaseStatus: "public" | "private" | "hidden" | "all";
    /**
     * UnityPackageID
     * @example unp_52b12c39-4163-457d-a4a9-630e7aff1bff
     */
    UnityPackageID: string;
    /**
     * UnityPackage
     * @example {
     *   "assetUrl": "https://api.vrchat.cloud/api/1/file/file_cd0caa7b-69ba-4715-8dfe-7d667a9d2537/65/file",
     *   "assetUrlObject": {},
     *   "assetVersion": 4,
     *   "created_at": "2020-09-10T06:13:27.777Z",
     *   "id": "unp_52b12c39-4163-457d-a4a9-630e7aff1bff",
     *   "platform": "standalonewindows",
     *   "pluginUrl": "",
     *   "pluginUrlObject": {},
     *   "unitySortNumber": 20180414000,
     *   "unityVersion": "2018.4.14f1"
     * }
     */
    UnityPackage: {
      assetUrl?: string;
      assetUrlObject?: Record<string, never>;
      assetVersion: number;
      /** Format: date-time */
      created_at?: string;
      id: components["schemas"]["UnityPackageID"];
      platform: components["schemas"]["Platform"];
      pluginUrl?: string;
      pluginUrlObject?: Record<string, never>;
      /** Format: int64 */
      unitySortNumber?: number;
      /**
       * @default 5.3.4p1
       * @example 2018.4.12f1
       */
      unityVersion: string;
    };
    /** Avatar */
    Avatar: {
      /** @description Not present from general serach `/avatars`, only on specific requests `/avatars/{avatarId}`. */
      assetUrl?: string;
      /**
       * @description Not present from general serach `/avatars`, only on specific requests `/avatars/{avatarId}`.
       * **Deprecation:** `Object` has unknown usage/fields, and is always empty. Use normal `Url` field instead.
       */
      assetUrlObject?: Record<string, never>;
      authorId: components["schemas"]["UserID"];
      authorName: string;
      /** Format: date-time */
      created_at: string;
      description: string;
      /** @default false */
      featured: boolean;
      id: components["schemas"]["AvatarID"];
      imageUrl: string;
      name: string;
      releaseStatus: components["schemas"]["ReleaseStatus"];
      /** @description */
      tags: components["schemas"]["Tag"][];
      thumbnailImageUrl: string;
      unityPackageUrl: string;
      /**
       * @deprecated
       * @description **Deprecation:** `Object` has unknown usage/fields, and is always empty. Use normal `Url` field instead.
       */
      unityPackageUrlObject: {
        unityPackageUrl?: string;
      };
      unityPackages: components["schemas"]["UnityPackage"][];
      /** Format: date-time */
      updated_at: string;
      /**
       * @default 0
       * @example 68
       */
      version: number;
    };
    /**
     * SortOption
     * @default popularity
     * @example popularity
     * @enum {string}
     */
    SortOption: "popularity" | "heat" | "trust" | "shuffle" | "random" | "favorites" | "reportScore" | "reportCount" | "publicationDate" | "labsPublicationDate" | "created" | "_created_at" | "updated" | "_updated_at" | "order" | "relevance" | "magic" | "name";
    /**
     * OrderOption
     * @default descending
     * @example descending
     * @enum {string}
     */
    OrderOption: "ascending" | "descending";
    /** CreateAvatarRequest */
    CreateAvatarRequest: {
      assetUrl?: string;
      id?: components["schemas"]["AvatarID"];
      name: string;
      description?: string;
      /** @description */
      tags?: components["schemas"]["Tag"][];
      imageUrl: string;
      releaseStatus?: components["schemas"]["ReleaseStatus"];
      /** @default 1 */
      version?: number;
      unityPackageUrl?: string;
    };
    /** UpdateAvatarRequest */
    UpdateAvatarRequest: {
      assetUrl?: string;
      id?: components["schemas"]["AvatarID"];
      name?: string;
      description?: string;
      /** @description */
      tags?: components["schemas"]["Tag"][];
      imageUrl?: string;
      releaseStatus?: components["schemas"]["ReleaseStatus"];
      /** @default 1 */
      version?: number;
      unityPackageUrl?: string;
    };
    /**
     * TransactionID
     * @example txn_e5c72948-e735-4880-8245-24b2a41198b0
     */
    TransactionID: string;
    /**
     * TransactionStatus
     * @default active
     * @enum {string}
     */
    TransactionStatus: "active" | "failed" | "expired" | "chargeback";
    /**
     * SubscriptionPeriod
     * @default month
     * @enum {string}
     */
    SubscriptionPeriod: "hour" | "day" | "week" | "month" | "year";
    /**
     * Subscription
     * @example {
     *   "id": "vrchatplus-yearly",
     *   "steamItemId": "5000",
     *   "amount": 9999,
     *   "description": "VRChat Plus (Yearly)",
     *   "period": "year",
     *   "tier": 5
     * }
     */
    Subscription: {
      id: string;
      steamItemId: string;
      amount: number;
      description: string;
      period: components["schemas"]["SubscriptionPeriod"];
      tier: number;
    };
    /**
     * TransactionSteamWalletInfo
     * @example {
     *   "state": "",
     *   "country": "SE",
     *   "currency": "EUR",
     *   "status": "Trusted"
     * }
     */
    TransactionSteamWalletInfo: {
      state: string;
      /**
       * @default US
       * @example SE
       */
      country: string;
      /**
       * @default USD
       * @example EUR
       */
      currency: string;
      /** @example Trusted */
      status: string;
    };
    /** TransactionSteamInfo */
    TransactionSteamInfo: {
      walletInfo: components["schemas"]["TransactionSteamWalletInfo"];
      /** @description Steam User ID */
      steamId: string;
      /** @description Steam Order ID */
      orderId: string;
      /** @description Empty */
      steamUrl: string;
      /** @description Steam Transaction ID, NOT the same as VRChat TransactionID */
      transId: string;
    };
    /**
     * TransactionAgreement
     * @example {
     *   "agreementId": "1234567890123456789",
     *   "itemId": 5000,
     *   "status": "Active",
     *   "period": "year",
     *   "frequency": 1,
     *   "billingType": "Steam",
     *   "startDate": "20220301",
     *   "endDate": "Infinite time value",
     *   "recurringAmt": 9999,
     *   "currency": "USD",
     *   "timeCreated": "20201201",
     *   "nextPayment": "20220301",
     *   "lastPayment": "NIL",
     *   "lastAmount": 0,
     *   "lastAmountVat": 0,
     *   "outstanding": 0,
     *   "failedAttempts": 0
     * }
     */
    TransactionAgreement: {
      agreementId: string;
      itemId: number;
      /** @description This is NOT TransactionStatus, but whatever Steam return. */
      status: string;
      period: string;
      frequency: number;
      billingType: string;
      startDate: string;
      endDate: string;
      recurringAmt: number;
      currency: string;
      timeCreated: string;
      nextPayment: string;
      lastPayment: string;
      lastAmount: number;
      lastAmountVat: number;
      outstanding: number;
      failedAttempts: number;
    };
    /** Transaction */
    Transaction: {
      id: components["schemas"]["TransactionID"];
      status: components["schemas"]["TransactionStatus"];
      subscription: components["schemas"]["Subscription"];
      /** @default false */
      sandbox: boolean;
      /** Format: date-time */
      created_at: string;
      /** Format: date-time */
      updated_at: string;
      steam?: components["schemas"]["TransactionSteamInfo"];
      agreement?: components["schemas"]["TransactionAgreement"];
      error: string;
    };
    /**
     * LicenseGroupID
     * @example lgrp_608513da-b213-4e15-80af-bd88c27f0979
     */
    LicenseGroupID: string;
    /**
     * UserSubscription
     * @example {
     *   "id": "vrchatplus-yearly",
     *   "transactionId": "txn_63231aa6-8b7a-49ff-a106-d5678f8318b1",
     *   "store": "Steam",
     *   "steamItemId": "5000",
     *   "amount": 9999,
     *   "description": "VRChat Plus (Yearly)",
     *   "period": "year",
     *   "tier": 5,
     *   "active": true,
     *   "status": "active",
     *   "expires": "2022-03-04T00:00:00.000Z",
     *   "created_at": "2020-12-04T13:09:54.344Z",
     *   "updated_at": "2020-12-10T19:53:45.362Z",
     *   "licenseGroups": [
     *     "lgrp_608513da-b213-4e15-80af-bd88c27f0979"
     *   ],
     *   "isGift": false
     * }
     */
    UserSubscription: {
      id: string;
      transactionId: components["schemas"]["TransactionID"];
      /** @description Which "Store" it came from. Right now only Stores are "Steam" and "Admin". */
      store: string;
      steamItemId?: string;
      amount: number;
      description: string;
      period: components["schemas"]["SubscriptionPeriod"];
      tier: number;
      /** @default true */
      active: boolean;
      status: components["schemas"]["TransactionStatus"];
      /** Format: date-time */
      expires: string;
      /** Format: date-time */
      created_at: string;
      /** Format: date-time */
      updated_at: string;
      licenseGroups: components["schemas"]["LicenseGroupID"][];
      /** @default false */
      isGift: boolean;
    };
    /**
     * LicenseType
     * @default permission
     * @example permission
     * @enum {string}
     */
    LicenseType: "avatar" | "licenseGroup" | "permission" | "product";
    /**
     * LicenseAction
     * @default have
     * @example have
     * @enum {string}
     */
    LicenseAction: "wear" | "have";
    /** License */
    License: {
      /** @description Either a AvatarID, LicenseGroupID, PermissionID or ProductID. This depends on the `forType` field. */
      forId: string;
      forType: components["schemas"]["LicenseType"];
      forName: string;
      forAction: components["schemas"]["LicenseAction"];
    };
    /**
     * LicenseGroup
     * @example {
     *   "id": "lgrp_608513da-b213-4e15-80af-bd88c27f0979",
     *   "name": "vrcplus",
     *   "description": "VRC+ benefits",
     *   "licenses": [
     *     {
     *       "forId": "prms_1d9549db-d30a-48f3-a6b8-6741ce5a4283",
     *       "forType": "permission",
     *       "forName": "permission-user-icons",
     *       "forAction": "have"
     *     },
     *     {
     *       "forId": "prms_76f33deb-dd5d-46b7-b79d-e1f8f0a9a1e0",
     *       "forType": "permission",
     *       "forName": "permission-supporter-tags",
     *       "forAction": "have"
     *     },
     *     {
     *       "forId": "prms_0d9549db-d30a-48f3-a6b8-6741ce5a4283",
     *       "forType": "permission",
     *       "forName": "permission-invite-photos",
     *       "forAction": "have"
     *     },
     *     {
     *       "forId": "prms_dc02c512-4c03-479c-8c6a-d9329c023baf",
     *       "forType": "permission",
     *       "forName": "permission-user-gallery",
     *       "forAction": "have"
     *     },
     *     {
     *       "forId": "prms_153ac0b7-c2dd-43f9-96e3-c61fd2e85509",
     *       "forType": "permission",
     *       "forName": "permission-profile-pic-override",
     *       "forAction": "have"
     *     }
     *   ]
     * }
     */
    LicenseGroup: {
      id: components["schemas"]["LicenseGroupID"];
      name: string;
      description: string;
      licenses: components["schemas"]["License"][];
    };
    /**
     * FavoriteID
     * @example fvrt_9568d189-8776-44a5-a8c8-defc981e44de
     */
    FavoriteID: string;
    /**
     * FavoriteType
     * @default friend
     * @enum {string}
     */
    FavoriteType: "world" | "friend" | "avatar";
    /** Favorite */
    Favorite: {
      /** @description MUST be either AvatarID, UserID or WorldID. */
      favoriteId: string;
      id: components["schemas"]["FavoriteID"];
      /** @description */
      tags: components["schemas"]["Tag"][];
      type: components["schemas"]["FavoriteType"];
    };
    /** AddFavoriteRequest */
    AddFavoriteRequest: {
      type: components["schemas"]["FavoriteType"];
      /** @description Must be either AvatarID, WorldID or UserID. */
      favoriteId: string;
      /** @description Tags indicate which group this favorite belongs to. Adding multiple groups makes it show up in all. Removing it from one in that case removes it from all. */
      tags: components["schemas"]["Tag"][];
    };
    /**
     * FavoriteGroupID
     * @example fvgrp_8a02a44b-dc3a-4a9a-bc77-77fa37996fc7
     */
    FavoriteGroupID: string;
    /**
     * FavoriteGroupVisibility
     * @default private
     * @example private
     * @enum {string}
     */
    FavoriteGroupVisibility: "private" | "friends" | "public";
    /** FavoriteGroup */
    FavoriteGroup: {
      displayName: string;
      id: components["schemas"]["FavoriteGroupID"];
      name: string;
      ownerDisplayName: string;
      ownerId: components["schemas"]["UserID"];
      /** @description */
      tags: components["schemas"]["Tag"][];
      type: components["schemas"]["FavoriteType"];
      visibility: components["schemas"]["FavoriteGroupVisibility"];
    };
    /** UpdateFavoriteGroupRequest */
    UpdateFavoriteGroupRequest: {
      displayName?: string;
      visibility?: components["schemas"]["FavoriteGroupVisibility"];
      /** @description Tags on FavoriteGroups are believed to do nothing. */
      tags?: components["schemas"]["Tag"][];
    };
    /**
     * FileID
     * @example file_ce35d830-e20a-4df0-a6d4-5aaef4508044
     */
    FileID: string;
    /**
     * MIMEType
     * @default image/jpeg
     * @example image/jpeg
     * @enum {string}
     */
    MIMEType: "image/jpeg" | "image/jpg" | "image/png" | "image/webp" | "image/gif" | "image/bmp" | "image/svg＋xml" | "image/tiff" | "application/x-avatar" | "application/x-world" | "application/gzip" | "application/x-rsync-signature" | "application/x-rsync-delta" | "application/octet-stream";
    /**
     * FileStatus
     * @default waiting
     * @example complete
     * @enum {string}
     */
    FileStatus: "waiting" | "complete" | "none" | "queued";
    /** FileData */
    FileData: {
      /**
       * @default queued
       * @enum {string}
       */
      category: "multipart" | "queued" | "simple";
      fileName: string;
      md5: string;
      sizeInBytes: number;
      status: components["schemas"]["FileStatus"];
      /** @default */
      uploadId: string;
      url: string;
    };
    /** FileVersion */
    FileVersion: {
      /** Format: date-time */
      created_at: string;
      /**
       * @description Usually only present if `true`
       * @default true
       */
      deleted?: boolean;
      delta?: components["schemas"]["FileData"];
      file?: components["schemas"]["FileData"];
      signature?: components["schemas"]["FileData"];
      status: components["schemas"]["FileStatus"];
      /**
       * @description Incremental version counter, can only be increased.
       * @default 0
       */
      version: number;
    };
    /** File */
    File: {
      /** @example .unitypackage */
      extension: string;
      id: components["schemas"]["FileID"];
      mimeType: components["schemas"]["MIMEType"];
      /** @example Example File */
      name: string;
      ownerId: components["schemas"]["UserID"];
      /** @description */
      tags: components["schemas"]["Tag"][];
      /** @description */
      versions: components["schemas"]["FileVersion"][];
    };
    /** CreateFileRequest */
    CreateFileRequest: {
      name: string;
      mimeType: components["schemas"]["MIMEType"];
      extension: string;
      /** @description */
      tags?: components["schemas"]["Tag"][];
    };
    /** CreateFileVersionRequest */
    CreateFileVersionRequest: {
      signatureMd5: string;
      signatureSizeInBytes: number;
      fileMd5?: string;
      fileSizeInBytes?: number;
    };
    /** FinishFileDataUploadRequest */
    FinishFileDataUploadRequest: {
      /** @description Array of ETags uploaded. */
      etags?: string[];
      /**
       * @deprecated
       * @description Always a zero in string form, despite how many parts uploaded.
       * @default 0
       * @example 0
       */
      nextPartNumber: string;
      /**
       * @deprecated
       * @description Always a zero in string form, despite how many parts uploaded.
       * @default 0
       * @example 0
       */
      maxParts: string;
    };
    /** FileUploadURL */
    FileUploadURL: {
      url: string;
    };
    /** FileVersionUploadStatus */
    FileVersionUploadStatus: {
      /** @example xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx_xxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxx_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx..xxxxxxxxxxxxxxxxxxxxxxx */
      uploadId: string;
      /** @example Avatar-MyAvatar-Un.file_00000000-0000-0000-0000-000000000000.1.unitypackage */
      fileName: string;
      /** @example 0 */
      nextPartNumber: number;
      /** @example 1000 */
      maxParts: number;
      parts: Record<string, never>[];
      /** @description Unknown */
      etags: Record<string, never>[];
    };
    /** LimitedUser */
    LimitedUser: {
      bio?: string;
      currentAvatarImageUrl: components["schemas"]["CurrentAvatarImageUrl"];
      currentAvatarThumbnailImageUrl: components["schemas"]["CurrentAvatarThumbnailImageUrl"];
      developerType: components["schemas"]["DeveloperType"];
      displayName: string;
      fallbackAvatar?: components["schemas"]["AvatarID"];
      id: components["schemas"]["UserID"];
      isFriend: boolean;
      last_platform: components["schemas"]["Platform"];
      profilePicOverride: string;
      status: components["schemas"]["UserStatus"];
      statusDescription: string;
      /** @description <- Always empty. */
      tags: components["schemas"]["Tag"][];
      userIcon: string;
      /**
       * @deprecated
       * @description -| **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429).
       */
      username?: string;
      location?: string;
      friendKey?: string;
    };
    /**
     * NotificationType
     * @default friendRequest
     * @enum {string}
     */
    NotificationType: "friendRequest" | "invite" | "inviteResponse" | "requestInvite" | "requestInviteResponse" | "votetokick";
    /** Notification */
    Notification: {
      /** Format: date-time */
      created_at: string;
      /**
       * @description **NOTICE:** This is not a JSON object when received from the REST API, but it is when received from the Websocket API. When received from the REST API, this is a json **encoded** object, meaning you have to json-de-encode to get the NotificationDetail object depending on the NotificationType.
       * @default {}
       * @example OneOf: {}, NotificationDetailInvite, NotificationDetailInviteResponse, NotificationDetailRequestInvite, NotificationDetailRequestInviteResponse, NotificationDetailVoteToKick
       */
      details: string;
      id: string;
      /** @example This is a generated invite to VRChat Hub */
      message: string;
      /**
       * @description Not included in notification objects received from the Websocket API
       * @default false
       */
      seen?: boolean;
      /** @description Not included in notification objects received from the REST API */
      receiverUserId?: components["schemas"]["UserID"];
      senderUserId: components["schemas"]["UserID"];
      /**
       * @deprecated
       * @description -| **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429).
       */
      senderUsername?: string;
      type: components["schemas"]["NotificationType"];
    };
    /** FriendStatus */
    FriendStatus: {
      /** @default false */
      incomingRequest: boolean;
      /** @default false */
      isFriend: boolean;
      /** @default false */
      outgoingRequest: boolean;
    };
    /**
     * GroupJoinState
     * @default open
     * @enum {string}
     */
    GroupJoinState: "closed" | "invite" | "request" | "open";
    /**
     * GroupPrivacy
     * @default default
     * @enum {string}
     */
    GroupPrivacy: "default" | "private";
    /**
     * GroupRoleTemplate
     * @default default
     * @enum {string}
     */
    GroupRoleTemplate: "default" | "managedFree" | "managedInvite" | "managedRequest";
    /** CreateGroupRequest */
    CreateGroupRequest: {
      name: string;
      shortCode: string;
      description?: string;
      joinState?: components["schemas"]["GroupJoinState"];
      /** @default null */
      iconId?: string | null;
      /** @default null */
      bannerId?: string | null;
      privacy?: components["schemas"]["GroupPrivacy"];
      roleTemplate: components["schemas"]["GroupRoleTemplate"];
    };
    /**
     * GroupShortCode
     * @example ABC123
     */
    GroupShortCode: string;
    /**
     * GroupDiscriminator
     * @example 1234
     */
    GroupDiscriminator: string;
    /**
     * GroupGalleryID
     * @example ggal_a03a4b55-4ca6-4490-9519-40ba6351a233
     */
    GroupGalleryID: string;
    /**
     * GroupRoleID
     * @example grol_459d3911-f672-44bc-b84d-e54ffe7960fe
     */
    GroupRoleID: string;
    /** GroupMember */
    GroupGallery: {
      id?: components["schemas"]["GroupGalleryID"];
      /**
       * @description Name of the gallery.
       * @example Example Gallery
       */
      name?: string;
      /**
       * @description Description of the gallery.
       * @example Example Description
       */
      description?: string;
      /**
       * @description Whether the gallery is members only.
       * @default false
       * @example false
       */
      membersOnly?: boolean;
      /** @description */
      roleIdsToView?: components["schemas"]["GroupRoleID"][] | null;
      /** @description */
      roleIdsToSubmit?: components["schemas"]["GroupRoleID"][] | null;
      /** @description */
      roleIdsToAutoApprove?: components["schemas"]["GroupRoleID"][] | null;
      /** @description */
      roleIdsToManage?: components["schemas"]["GroupRoleID"][] | null;
      /** Format: date-time */
      createdAt?: string;
      /** Format: date-time */
      updatedAt?: string;
    };
    /**
     * @default inactive
     * @example member
     * @enum {string}
     */
    GroupMemberStatus: "inactive" | "member" | "requested" | "invited";
    /**
     * GroupMemberID
     * @example gmem_95cdb3b4-4643-4eb6-bdab-46a4e1e5ce37
     */
    GroupMemberID: string;
    /** GroupMyMember */
    GroupMyMember: {
      id?: components["schemas"]["GroupMemberID"];
      groupId?: components["schemas"]["GroupID"];
      userId?: components["schemas"]["UserID"];
      roleIds?: components["schemas"]["GroupRoleID"][];
      managerNotes?: string;
      /** @example member */
      membershipStatus?: string;
      /** @default true */
      isSubscribedToAnnouncements?: boolean;
      /** @example visible */
      visibility?: string;
      /** @default false */
      isRepresenting?: boolean;
      /** Format: date-time */
      joinedAt?: string;
      bannedAt?: string | null;
      /** @default false */
      has2FA?: boolean;
      permissions?: string[];
    };
    /** GroupRole */
    GroupRole: {
      id?: components["schemas"]["GroupRoleID"];
      groupId?: components["schemas"]["GroupID"];
      name?: string;
      description?: string;
      /** @default false */
      isSelfAssignable?: boolean;
      permissions?: string[];
      /** @default false */
      isManagementRole?: boolean;
      /** @default false */
      requiresTwoFactor?: boolean;
      /** @default false */
      requiresPurchase?: boolean;
      order?: number;
      /** Format: date-time */
      createdAt?: string;
      /** Format: date-time */
      updatedAt?: string;
    };
    /** Group */
    Group: {
      id?: components["schemas"]["GroupID"];
      name?: string;
      shortCode?: components["schemas"]["GroupShortCode"];
      discriminator?: components["schemas"]["GroupDiscriminator"];
      description?: string;
      iconUrl?: string | null;
      bannerUrl?: string | null;
      privacy?: components["schemas"]["GroupPrivacy"];
      ownerId?: components["schemas"]["UserID"];
      rules?: string | null;
      links?: string[];
      languages?: string[];
      iconId?: string | null;
      bannerId?: string | null;
      memberCount?: number;
      /** Format: date-time */
      memberCountSyncedAt?: string;
      /** @default false */
      isVerified?: boolean;
      joinState?: components["schemas"]["GroupJoinState"];
      /** @description */
      tags?: components["schemas"]["Tag"][];
      /** @description */
      galleries?: components["schemas"]["GroupGallery"][];
      /** Format: date-time */
      createdAt?: string;
      onlineMemberCount?: number;
      membershipStatus?: components["schemas"]["GroupMemberStatus"];
      myMember?: components["schemas"]["GroupMyMember"];
      /** @description Only returned if ?includeRoles=true is specified. */
      roles?: components["schemas"]["GroupRole"][] | null;
    };
    /** UpdateGroupRequest */
    UpdateGroupRequest: {
      name?: string;
      shortCode?: string;
      description?: string;
      joinState?: components["schemas"]["GroupJoinState"];
      /** @default null */
      iconId?: string | null;
      /** @default null */
      bannerId?: string | null;
      /** @description 3 letter language code */
      languages?: string[];
      links?: string[];
      rules?: string;
      /** @description */
      tags?: components["schemas"]["Tag"][];
    };
    /**
     * GroupAnnouncementID
     * @example gpos_71a7ff59-112c-4e78-a990-c7cc650776e5
     */
    GroupAnnouncementID: string;
    /** GroupAnnouncement */
    GroupAnnouncement: {
      id?: components["schemas"]["GroupAnnouncementID"];
      groupId?: components["schemas"]["GroupID"];
      authorId?: components["schemas"]["UserID"];
      title?: string | null;
      text?: string | null;
      imageId?: components["schemas"]["FileID"];
      imageUrl?: string | null;
      /** Format: date-time */
      createdAt?: string | null;
      /** Format: date-time */
      updatedAt?: string | null;
    };
    /** CreateGroupAnnouncementRequest */
    CreateGroupAnnouncementRequest: {
      /**
       * @description Announcement title
       * @example Event is starting soon!
       */
      title: string;
      /**
       * @description Announcement text
       * @example Come join us for the event!
       */
      text?: string;
      imageId?: components["schemas"]["FileID"];
      /**
       * @description Send notification to group members.
       * @default false
       * @example false
       */
      sendNotification?: boolean;
    };
    /**
     * GroupAuditLogID
     * @example gaud_71a7ff59-112c-4e78-a990-c7cc650776e5
     */
    GroupAuditLogID: string;
    /** GroupAuditLogEntry */
    GroupAuditLogEntry: {
      id?: components["schemas"]["GroupAuditLogID"];
      /** Format: date-time */
      created_at?: string;
      groupId?: components["schemas"]["GroupID"];
      actorId?: components["schemas"]["UserID"];
      actorDisplayname?: string;
      /** @description Typically GroupID or GroupRoleID, but could be other types of IDs. */
      targetId?: string;
      /**
       * @description The type of event that occurred. This is a string that is prefixed with the type of object that the event occurred on. For example, a group role update event would be prefixed with `group.role`.
       * @default group.update
       * @example group.role.update
       */
      eventType?: string;
      /**
       * @description A human-readable description of the event.
       * @example Group role updated
       */
      description?: string;
      /**
       * @description The data associated with the event. The format of this data is dependent on the event type.
       * @example {
       *   "description": {
       *     "old": "My exciting new group.  It's pretty nifty!",
       *     "new": "My exciting new group. It's pretty nifty!"
       *   },
       *   "joinState": {
       *     "old": "closed",
       *     "new": "request"
       *   }
       * }
       */
      data?: Record<string, never>;
    };
    /** PaginatedGroupAuditLogEntryList */
    PaginatedGroupAuditLogEntryList: {
      /** @description */
      results?: components["schemas"]["GroupAuditLogEntry"][];
      /** @description The total number of results that the query would return if there were no pagination. */
      totalCount?: number;
      /** @description Whether there are more results after this page. */
      hasNext?: boolean;
    };
    /**
     * GroupMemberLimitedUser
     * @description Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user.
     */
    GroupMemberLimitedUser: {
      id?: components["schemas"]["UserID"];
      displayName?: string;
      thumbnailUrl?: string;
      iconUrl?: string;
    };
    /** GroupMember */
    GroupMember: {
      id?: components["schemas"]["GroupMemberID"];
      groupId?: components["schemas"]["GroupID"];
      userId?: components["schemas"]["UserID"];
      /**
       * @description Whether the user is representing the group. This makes the group show up above the name tag in-game.
       * @default false
       * @example true
       */
      isRepresenting?: boolean;
      user?: components["schemas"]["GroupMemberLimitedUser"];
      roleIds?: components["schemas"]["GroupRoleID"][];
      /** Format: date-time */
      joinedAt?: string;
      /** @example member */
      membershipStatus?: string;
      /** @example visible */
      visibility?: string;
      /** @default false */
      isSubscribedToAnnouncements?: boolean;
      /**
       * Format: date-time
       * @description Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user.
       */
      createdAt?: string | null;
      /**
       * Format: date-time
       * @description Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user.
       */
      bannedAt?: string | null;
      /** @description Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user. */
      managerNotes?: string | null;
    };
    /** BanGroupMemberRequest */
    BanGroupMemberRequest: {
      userId: components["schemas"]["UserID"];
    };
    /** CreateGroupGalleryRequest */
    CreateGroupGalleryRequest: {
      /**
       * @description Name of the gallery.
       * @example Example Gallery
       */
      name: string;
      /**
       * @description Description of the gallery.
       * @example Example Description
       */
      description?: string;
      /**
       * @description Whether the gallery is members only.
       * @default false
       * @example false
       */
      membersOnly?: boolean;
      /** @description */
      roleIdsToView?: components["schemas"]["GroupRoleID"][] | null;
      /** @description */
      roleIdsToSubmit?: components["schemas"]["GroupRoleID"][] | null;
      /** @description */
      roleIdsToAutoApprove?: components["schemas"]["GroupRoleID"][] | null;
      /** @description */
      roleIdsToManage?: components["schemas"]["GroupRoleID"][] | null;
    };
    /**
     * GroupGalleryImageID
     * @example ggim_71a7ff59-112c-4e78-a990-c7cc650776e5
     */
    GroupGalleryImageID: string;
    /** GroupGalleryImage */
    GroupGalleryImage: {
      id?: components["schemas"]["GroupGalleryImageID"];
      groupId?: components["schemas"]["GroupID"];
      galleryId?: components["schemas"]["GroupGalleryID"];
      fileId?: components["schemas"]["FileID"];
      /**
       * Format: uri
       * @example https://api.vrchat.cloud/api/1/file/file_ce35d830-e20a-4df0-a6d4-5aaef4508044/1/file
       */
      imageUrl?: string;
      /** Format: date-time */
      createdAt?: string;
      submittedByUserId?: components["schemas"]["UserID"];
      /**
       * @default false
       * @example true
       */
      approved?: boolean;
      approvedByUserId?: components["schemas"]["UserID"];
      /** Format: date-time */
      approvedAt?: string;
    };
    /** UpdateGroupGalleryRequest */
    UpdateGroupGalleryRequest: {
      /**
       * @description Name of the gallery.
       * @example Example Gallery
       */
      name?: string;
      /**
       * @description Description of the gallery.
       * @example Example Description
       */
      description?: string;
      /**
       * @description Whether the gallery is members only.
       * @default false
       * @example false
       */
      membersOnly?: boolean;
      /** @description */
      roleIdsToView?: components["schemas"]["GroupRoleID"][] | null;
      /** @description */
      roleIdsToSubmit?: components["schemas"]["GroupRoleID"][] | null;
      /** @description */
      roleIdsToAutoApprove?: components["schemas"]["GroupRoleID"][] | null;
      /** @description */
      roleIdsToManage?: components["schemas"]["GroupRoleID"][] | null;
    };
    /** AddGroupGalleryImageRequest */
    AddGroupGalleryImageRequest: {
      fileId: components["schemas"]["FileID"];
    };
    /** CreateGroupInviteRequest */
    CreateGroupInviteRequest: {
      userId: components["schemas"]["UserID"];
      /** @default true */
      confirmOverrideBlock?: boolean;
    };
    /** GroupLimitedMember */
    GroupLimitedMember: {
      id?: components["schemas"]["GroupMemberID"];
      groupId?: components["schemas"]["GroupID"];
      userId?: components["schemas"]["UserID"];
      /** @default false */
      isRepresenting?: boolean;
    };
    /**
     * GroupUserVisibility
     * @example visible
     * @enum {string}
     */
    GroupUserVisibility: "visible" | "hidden" | "friends";
    /** UpdateGroupMemberRequest */
    UpdateGroupMemberRequest: {
      visibility?: components["schemas"]["GroupUserVisibility"];
      isSubscribedToAnnouncements?: boolean;
      managerNotes?: string;
    };
    /**
     * GroupRoleIDList
     * @description
     */
    GroupRoleIDList: components["schemas"]["GroupRoleID"][];
    /**
     * GroupPermission
     * @description A permission that can be granted to a role in a group.
     */
    GroupPermission: {
      /**
       * @description The name of the permission.
       * @example group-data-manage
       */
      name?: string;
      /**
       * @description The display name of the permission.
       * @example Manage Group Data
       */
      displayName?: string;
      /**
       * @description Human-readable description of the permission.
       * @example Allows role to edit group details (name, description, joinState, initialRoles, etc).
       */
      help?: string;
      /**
       * @description Whether this permission is a "management" permission.
       * @default false
       * @example true
       */
      isManagementPermission?: boolean;
      /**
       * @description Whether the user is allowed to add this permission to a role.
       * @default false
       * @example true
       */
      allowedToAdd?: boolean;
    };
    /** RespondGroupJoinRequest */
    RespondGroupJoinRequest: {
      action?: string;
    };
    /** CreateGroupRequest */
    CreateGroupRoleRequest: {
      id?: string;
      name?: string;
      description?: string;
      /** @default false */
      isSelfAssignable?: boolean;
      permissions?: string[];
    };
    /** UpdateGroupRoleRequest */
    UpdateGroupRoleRequest: {
      name?: string;
      description?: string;
      /** @default false */
      isSelfAssignable?: boolean;
      permissions?: string[];
      order?: number;
    };
    /**
     * InstanceID
     * @description InstanceID can be "offline" on User profiles if you are not friends with that user and "private" if you are friends and user is in private instance.
     * @example wrld_ba913a96-fac4-4048-a062-9aa5db092812:12345~hidden(usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469)~region(eu)~nonce(27e8414a-59a0-4f3d-af1f-f27557eb49a2)
     */
    InstanceID: string;
    /** InviteRequest */
    InviteRequest: {
      instanceId: components["schemas"]["InstanceID"];
      messageSlot?: number;
    };
    /** SentNotification */
    SentNotification: {
      /** Format: date-time */
      created_at: string;
      /**
       * @description **NOTICE:** This is not a JSON object, this is a json **encoded** object, meaning you have to json-de-encode to get the NotificationDetail object depending on the NotificationType.
       * @default {}
       * @example OneOf: {}, NotificationDetailInvite, NotificationDetailInviteResponse, NotificationDetailRequestInvite, NotificationDetailRequestInviteResponse, NotificationDetailVoteToKick
       */
      details: string;
      id: string;
      /** @example This is a generated invite to VRChat Hub */
      message: string;
      recieverUserId: components["schemas"]["UserID"];
      senderUserId: components["schemas"]["UserID"];
      /**
       * @deprecated
       * @description -| **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429).
       */
      senderUsername?: string;
      type: components["schemas"]["NotificationType"];
    };
    /** RequestInviteRequest */
    RequestInviteRequest: {
      messageSlot?: number;
    };
    /** InviteResponse */
    InviteResponse: {
      responseSlot: number;
    };
    /**
     * InviteMessageType
     * @default message
     * @enum {string}
     */
    InviteMessageType: "message" | "response" | "request" | "requestResponse";
    /**
     * InviteMessageID
     * @example invm_24a1c14d-5e24-48e5-90e3-c3f712420ffa
     */
    InviteMessageID: string;
    /** InviteMessage */
    InviteMessage: {
      /** @default true */
      canBeUpdated: boolean;
      id: components["schemas"]["InviteMessageID"];
      message: string;
      messageType: components["schemas"]["InviteMessageType"];
      /**
       * @description Changes to 60 when updated, although probably server-side configurable.
       * @default 0
       */
      remainingCooldownMinutes: number;
      slot: number;
      /** Format: date-time */
      updatedAt: string;
    };
    /** UpdateInviteMessageRequest */
    UpdateInviteMessageRequest: {
      message: string;
    };
    /**
     * Region
     * @description API/Photon region.
     * @default us
     * @example eu
     * @enum {string}
     */
    Region: "us" | "use" | "usw" | "eu" | "jp" | "unknown";
    /** InstancePlatforms */
    InstancePlatforms: {
      /** @example 1 */
      android: number;
      /** @example 5 */
      standalonewindows: number;
    };
    /**
     * InstanceType
     * @example hidden
     * @enum {string}
     */
    InstanceType: "public" | "hidden" | "friends" | "private" | "group";
    /**
     * Instance
     * @description * `hidden` field is only present if InstanceType is `hidden` aka "Friends+", and is instance creator.
     * * `friends` field is only present if InstanceType is `friends` aka "Friends", and is instance creator.
     * * `private` field is only present if InstanceType is `private` aka "Invite" or "Invite+", and is instance creator.
     */
    Instance: {
      /**
       * @default true
       * @example true
       */
      active: boolean;
      /**
       * @default true
       * @example true
       */
      canRequestInvite: boolean;
      /** @example 8 */
      capacity: number;
      /**
       * @deprecated
       * @description Always returns "unknown".
       */
      clientNumber: string;
      /** @default false */
      full: boolean;
      id: components["schemas"]["InstanceID"];
      /** @example 12345~hidden(usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469)~region(eu)~nonce(27e8414a-59a0-4f3d-af1f-f27557eb49a2) */
      instanceId: string;
      location: components["schemas"]["InstanceID"];
      /** @example 6 */
      n_users: number;
      /** @example 12345 */
      name: string;
      ownerId?: components["schemas"]["UserID"];
      /** @default false */
      permanent: boolean;
      photonRegion: components["schemas"]["Region"];
      platforms: components["schemas"]["InstancePlatforms"];
      region: components["schemas"]["Region"];
      /** @example 7eavhhng */
      secureName: string;
      /** @example 02u7yz8j */
      shortName?: string;
      /**
       * @description The tags array on Instances usually contain the language tags of the people in the instance.
       * @example [
       *   "show_social_rank",
       *   "language_eng",
       *   "language_jpn"
       * ]
       */
      tags: components["schemas"]["Tag"][];
      type: components["schemas"]["InstanceType"];
      worldId: components["schemas"]["WorldID"];
      hidden?: components["schemas"]["UserID"];
      friends?: components["schemas"]["UserID"];
      private?: components["schemas"]["UserID"];
    };
    /** InstanceShortNameResponse */
    InstanceShortNameResponse: {
      /** @example 7eavhhng */
      secureName: string;
      /** @example 02u7yz8j */
      shortName?: string;
    };
    /**
     * PermissionID
     * @example prms_804ba021-9f47-4e25-9847-1f42fdb2e6ff
     */
    PermissionID: string;
    /**
     * Permission
     * @example {
     *   "data": {
     *     "maxFavoriteGroups": {
     *       "avatar": 4
     *     },
     *     "maxFavoritesPerGroup": {
     *       "avatar": 25
     *     }
     *   },
     *   "id": "prms_804ba021-9f47-4e25-9847-1f42fdb2e6ff",
     *   "name": "permission-extra-favorites-avatar-groups",
     *   "ownerId": "usr_17f19d1e-fd48-493b-a8ad-807a3d8bdd1b"
     * }
     */
    Permission: {
      id: components["schemas"]["PermissionID"];
      /** @example permission-invite-photos */
      name: string;
      ownerId: components["schemas"]["UserID"];
      data?: Record<string, never>;
    };
    /**
     * PlayerModerationID
     * @example pmod_25551a8d-6f5d-430a-88d3-9c0ce08b5244
     */
    PlayerModerationID: string;
    /**
     * PlayerModerationType
     * @default unmute
     * @example unmute
     * @enum {string}
     */
    PlayerModerationType: "mute" | "unmute" | "block" | "unblock" | "interactOn" | "interactOff";
    /** PlayerModeration */
    PlayerModeration: {
      /** Format: date-time */
      created: string;
      id: components["schemas"]["PlayerModerationID"];
      sourceDisplayName: string;
      sourceUserId: components["schemas"]["UserID"];
      targetDisplayName: string;
      targetUserId: components["schemas"]["UserID"];
      type: components["schemas"]["PlayerModerationType"];
    };
    /** ModerateUserRequest */
    ModerateUserRequest: {
      moderated: components["schemas"]["UserID"];
      type: components["schemas"]["PlayerModerationType"];
    };
    /**
     * APIConfigAnnouncement
     * @deprecated
     * @description Public Announcement
     */
    APIConfigAnnouncement: {
      /** @description Announcement name */
      name: string;
      /** @description Announcement text */
      text: string;
    };
    /**
     * DeploymentGroup
     * @description Used to identify which API deployment cluster is currently responding.
     *
     * `blue` and `green` are used by Production.
     * `grape`and `cherry` are used during Development.
     *
     * [Blue Green Deployment by Martin Fowler](https://martinfowler.com/bliki/BlueGreenDeployment.html)
     * @default blue
     * @enum {string}
     */
    DeploymentGroup: "blue" | "green" | "grape" | "cherry";
    /**
     * APIConfigDownloadURLList
     * @description Download links for various development assets.
     */
    APIConfigDownloadURLList: {
      /**
       * @deprecated
       * @description Download link for legacy SDK2
       */
      sdk2: string;
      /** @description Download link for SDK3 for Avatars */
      "sdk3-avatars": string;
      /** @description Download link for SDK3 for Worlds */
      "sdk3-worlds": string;
      /** @description Download link for the Creator Companion */
      vcc: string;
      /** @description Download link for ??? */
      bootstrap: string;
    };
    /** DynamicContentRow */
    DynamicContentRow: {
      index?: number;
      name: string;
      /** @description Usually "ThisPlatformSupported", but can also be other values such as "all" or platform specific identifiers. */
      platform: string;
      sortHeading: string;
      sortOrder: string;
      sortOwnership: string;
      /** @description Tag to filter content for this row. */
      tag?: string;
      /**
       * @description Type is not present if it is a world.
       * @example avatar
       */
      type?: string;
    };
    /** APIConfigEvents */
    APIConfigEvents: {
      /** @description Unknown */
      distanceClose: number;
      /** @description Unknown */
      distanceFactor: number;
      /** @description Unknown */
      distanceFar: number;
      /** @description Unknown */
      groupDistance: number;
      /** @description Unknown */
      maximumBunchSize: number;
      /** @description Unknown */
      notVisibleFactor: number;
      /** @description Unknown */
      playerOrderBucketSize: number;
      /** @description Unknown */
      playerOrderFactor: number;
      /** @description Unknown */
      slowUpdateFactorThreshold: number;
      /** @description Unknown */
      viewSegmentLength: number;
    };
    /**
     * APIConfig
     * @example {
     *   "VoiceEnableDegradation": false,
     *   "VoiceEnableReceiverLimiting": true,
     *   "address": "1062 Folsom St., Suite 200, San Francisco, CA, 94103",
     *   "announcements": [
     *     {
     *       "name": "220121a_modified_clients",
     *       "text": "As part of our continued commitment to improve\nsafety and awareness, we want to remind you that\n<color='red'>modified clients of any kind are not allowed\non VRChat</color>, for any reason, and are prohibited\nby the Terms of Service.\n\nThere is no such thing as an 'approved'\nmodification, nor do we permit the use of\nany modification, for any purpose, ever.\n<color='red'>Using them can and will result in your\naccount being banned!</color>\n\nIn addition, modified clients are the single\ngreatest source of <color='red'>compromised and stolen\naccounts</color>-- so please, do not use them!"
     *     }
     *   ],
     *   "appName": "VrChat",
     *   "buildVersionTag": "master-build-2021-09-23-edith-x-clickbaitcloud",
     *   "clientApiKey": "JlE5Jldo5Jibnk5O5hTx6XVqsJu4WJ26",
     *   "clientBPSCeiling": 18432,
     *   "clientDisconnectTimeout": 30000,
     *   "clientReservedPlayerBPS": 7168,
     *   "clientSentCountAllowance": 15,
     *   "contactEmail": "hello@vrchat.com",
     *   "copyrightEmail": "copyright@vrchat.com",
     *   "currentTOSVersion": 7,
     *   "defaultAvatar": "avtr_c38a1615-5bf5-42b4-84eb-a8b6c37cbd11",
     *   "deploymentGroup": "blue",
     *   "devAppVersionStandalone": "0.12.0p3",
     *   "devDownloadLinkWindows": "www.vrchat.net",
     *   "devSdkUrl": "https://vrchat.com/home/download",
     *   "devSdkVersion": "2020.09.25.00.08",
     *   "devServerVersionStandalone": "dev_server_01",
     *   "dis-countdown": "2021-01-01T01:01:01.000Z",
     *   "disableAvatarCopying": false,
     *   "disableAvatarGating": false,
     *   "disableCommunityLabs": false,
     *   "disableCommunityLabsPromotion": false,
     *   "disableEmail": false,
     *   "disableEventStream": false,
     *   "disableFeedbackGating": false,
     *   "disableFrontendBuilds": false,
     *   "disableHello": false,
     *   "disableOculusSubs": false,
     *   "disableRegistration": false,
     *   "disableSteamNetworking": true,
     *   "disableTwoFactorAuth": false,
     *   "disableUdon": false,
     *   "disableUpgradeAccount": false,
     *   "downloadLinkWindows": "https://www.oculus.com/experiences/rift/997678176960598/",
     *   "downloadUrls": {
     *     "sdk2": "https://files.vrchat.cloud/sdk/VRCSDK2-2021.09.03.09.25_Public.unitypackage",
     *     "sdk3-avatars": "https://files.vrchat.cloud/sdk/VRCSDK3-AVATAR-2021.09.03.09.25_Public.unitypackage",
     *     "sdk3-worlds": "https://files.vrchat.cloud/sdk/VRCSDK3-WORLD-2021.09.03.09.25_Public.unitypackage",
     *     "vcc": "https://vrcpm.vrchat.cloud/vcc/Builds/2.1.1/VRChat_CreatorCompanion_Setup_2.1.1.exe",
     *     "bootstrap": "https://github.com/vrchat/packages/releases/download/resolvers/latest-resolver.unitypackage"
     *   },
     *   "dynamicWorldRows": [
     *     {
     *       "index": 1,
     *       "name": "Hot",
     *       "platform": "ThisPlatformSupported",
     *       "sortHeading": "heat",
     *       "sortOrder": "descending",
     *       "sortOwnership": "any"
     *     },
     *     {
     *       "index": 2,
     *       "name": "World Jam: Obstacle Course",
     *       "platform": "ThisPlatformSupported",
     *       "sortHeading": "order",
     *       "sortOrder": "ascending",
     *       "sortOwnership": "any",
     *       "tag": "admin_jam_obstacle"
     *     },
     *     {
     *       "index": 3,
     *       "name": "Exercise",
     *       "platform": "Any",
     *       "sortHeading": "shuffle",
     *       "sortOrder": "descending",
     *       "sortOwnership": "any",
     *       "tag": "admin_exercise_row"
     *     },
     *     {
     *       "index": 4,
     *       "name": "Spotlight",
     *       "platform": "ThisPlatformSupported",
     *       "sortHeading": "updated",
     *       "sortOrder": "descending",
     *       "sortOwnership": "any",
     *       "tag": "admin_community_spotlight"
     *     },
     *     {
     *       "index": 5,
     *       "name": "Community Labs",
     *       "platform": "ThisPlatformSupported",
     *       "sortHeading": "labs",
     *       "sortOrder": "descending",
     *       "sortOwnership": "any"
     *     },
     *     {
     *       "index": 6,
     *       "name": "Active Cross Platform",
     *       "platform": "AllPlatforms",
     *       "sortHeading": "active",
     *       "sortOrder": "descending",
     *       "sortOwnership": "any"
     *     },
     *     {
     *       "index": 7,
     *       "name": "Active My Platform",
     *       "platform": "ThisPlatformOnly",
     *       "sortHeading": "active",
     *       "sortOrder": "descending",
     *       "sortOwnership": "any"
     *     },
     *     {
     *       "index": 8,
     *       "name": "Random",
     *       "platform": "ThisPlatformSupported",
     *       "sortHeading": "shuffle",
     *       "sortOrder": "descending",
     *       "sortOwnership": "any"
     *     },
     *     {
     *       "index": 9,
     *       "name": "Avatar Worlds",
     *       "platform": "ThisPlatformSupported",
     *       "sortHeading": "heat",
     *       "sortOrder": "descending",
     *       "sortOwnership": "any",
     *       "tag": "author_tag_avatar"
     *     },
     *     {
     *       "index": 10,
     *       "name": "Games",
     *       "platform": "ThisPlatformSupported",
     *       "sortHeading": "heat",
     *       "sortOrder": "descending",
     *       "sortOwnership": "any",
     *       "tag": "author_tag_game"
     *     },
     *     {
     *       "index": 11,
     *       "name": "Updated Recently",
     *       "platform": "ThisPlatformSupported",
     *       "sortHeading": "updated",
     *       "sortOrder": "descending",
     *       "sortOwnership": "any"
     *     },
     *     {
     *       "index": 12,
     *       "name": "New",
     *       "platform": "ThisPlatformSupported",
     *       "sortHeading": "publication",
     *       "sortOrder": "descending",
     *       "sortOwnership": "any"
     *     },
     *     {
     *       "index": 13,
     *       "name": "Recent",
     *       "platform": "ThisPlatformSupported",
     *       "sortHeading": "recent",
     *       "sortOrder": "descending",
     *       "sortOwnership": "any"
     *     },
     *     {
     *       "index": 14,
     *       "name": "Mine",
     *       "platform": "any",
     *       "sortHeading": "updated",
     *       "sortOrder": "descending",
     *       "sortOwnership": "mine"
     *     },
     *     {
     *       "index": 15,
     *       "name": "Classics",
     *       "platform": "ThisPlatformSupported",
     *       "sortHeading": "trending",
     *       "sortOrder": "descending",
     *       "sortOwnership": "any"
     *     }
     *   ],
     *   "events": {
     *     "distanceClose": 2,
     *     "distanceFactor": 100,
     *     "distanceFar": 80,
     *     "groupDistance": 3,
     *     "maximumBunchSize": 247,
     *     "notVisibleFactor": 100,
     *     "playerOrderBucketSize": 5,
     *     "playerOrderFactor": 55,
     *     "slowUpdateFactorThreshold": 25,
     *     "viewSegmentLength": 5
     *   },
     *   "gearDemoRoomId": "2282253502",
     *   "homeWorldId": "wrld_4432ea9b-729c-46e3-8eaf-846aa0a37fdd",
     *   "homepageRedirectTarget": "https://hello.vrchat.com",
     *   "hubWorldId": "wrld_ba913a96-fac4-4048-a062-9aa5db092812",
     *   "jobsEmail": "jobs@vrchat.com",
     *   "messageOfTheDay": "hello world",
     *   "moderationEmail": "moderation@vrchat.com",
     *   "moderationQueryPeriod": 60,
     *   "notAllowedToSelectAvatarInPrivateWorldMessage": "For security reasons, you're not yet allowed to select avatars in private worlds or upload content. Please continue to enjoy VRChat and we'll message you when you've been unlocked. Thanks and have fun!",
     *   "plugin": "no_kick_unlisted",
     *   "releaseAppVersionStandalone": "0.12.0p3",
     *   "releaseSdkUrl": "http://files.vrchat.cloud/sdk/VRCSDK-2019.09.18.12.05_Public.unitypackage",
     *   "releaseSdkVersion": "VRCSDK-2019.09.18.12.05_Public",
     *   "releaseServerVersionStandalone": "public_server_01",
     *   "sdkDeveloperFaqUrl": "https://docs.vrchat.com/docs/frequently-asked-questions#section-why-can-t-i-upload-content-yet-",
     *   "sdkDiscordUrl": "https://discord.gg/vrchat",
     *   "sdkNotAllowedToPublishMessage": "Welcome the VRChat SDK!\r\n\r\nBefore you can upload avatars or worlds to VRChat, you'll need to spend more time enjoying the app. We do this for security reasons, and so you can learn more about us.\r\n\r\nWhen you get the ability to upload, we will notify you via email and in VRChat. For now, you can learn and test on your own device.\r\n\r\nTo get started, check out the resources below.\r\n\r\nThank you for your patience, we can't wait to see what you'll build!",
     *   "sdkUnityVersion": "2019.4.30f1",
     *   "serverName": "prod-api-blue-house-fsm",
     *   "supportEmail": "support@vrchat.com",
     *   "timeOutWorldId": "wrld_5b89c79e-c340-4510-be1b-476e9fcdedcc",
     *   "tutorialWorldId": "wld_7d3d25ec-663e-406e-96a3-e2c4fc0d8104",
     *   "updateRateMsMaximum": 1000,
     *   "updateRateMsMinimum": 50,
     *   "updateRateMsNormal": 200,
     *   "updateRateMsUdonManual": 50,
     *   "uploadAnalysisPercent": 1,
     *   "urlList": [
     *     "drive.google.com",
     *     "facebook.com",
     *     "www.facebook.com",
     *     "nicovideo.jp",
     *     "www.nicovideo.jp",
     *     "live.nicovideo.jp",
     *     "live2.nicovideo.jp",
     *     "game.nicovideo.jp",
     *     "soundcloud.com",
     *     "tiktok.com",
     *     "www.tiktok.com",
     *     "twitch.tv",
     *     "www.twitch.tv",
     *     "vimeo.com",
     *     "player.vimeo.com",
     *     "vrchat.cloud",
     *     "youku.com",
     *     "v.youku.com",
     *     "youtube.com",
     *     "www.youtube.com",
     *     "youtu.be",
     *     "assets.vrchat.com",
     *     "www.v-market.work",
     *     "vket6.v-market.work",
     *     "mall.v-market.work",
     *     "cdn.v-market.work",
     *     "movie.cdn.v-market.work",
     *     "wrs.nedo.go.jp"
     *   ],
     *   "useReliableUdpForVoice": false,
     *   "userUpdatePeriod": 60,
     *   "userVerificationDelay": 5,
     *   "userVerificationRetry": 30,
     *   "userVerificationTimeout": 60,
     *   "viveWindowsUrl": "http://store.steampowered.com/app/438100/",
     *   "whiteListedAssetUrls": [
     *     "http://dbinj8iahsbec.cloudfront.net/plugins",
     *     "http://dbinj8iahsbec.cloudfront.net/",
     *     "https://dbinj8iahsbec.cloudfront.net/",
     *     "https://dev-api.vrchat.cloud/api/1/file/",
     *     "https://api.vrchat.cloud/api/1/file/",
     *     "https://files.vrchat.cloud/unmanaged/"
     *   ],
     *   "worldUpdatePeriod": 60,
     *   "player-url-resolver-hash": "E3-C6-63-C3-27-3F-1C-47-48-C6-A7-52-A1-53-03-A5-10-6C-45-37-B1-C3-14-70-BA-44-1F-AE-0E-B2-32-36",
     *   "player-url-resolver-version": "2021-05-16T00:00:00.000Z"
     * }
     */
    APIConfig: {
      /**
       * @description Unknown, probably voice optimization testing
       * @default false
       */
      VoiceEnableDegradation: boolean;
      /**
       * @description Unknown, probably voice optimization testing
       * @default true
       */
      VoiceEnableReceiverLimiting: boolean;
      /** @description VRChat's office address */
      address: string;
      /** @description Public Announcements */
      announcements: components["schemas"]["APIConfigAnnouncement"][];
      /**
       * @deprecated
       * @description Game name
       * @default VrChat
       */
      appName: string;
      /** @description Build tag of the API server */
      buildVersionTag: string;
      /** @description apiKey to be used for all other requests */
      clientApiKey: string;
      /**
       * @description Unknown
       * @default 18432
       */
      clientBPSCeiling: number;
      /**
       * @description Unknown
       * @default 30000
       */
      clientDisconnectTimeout: number;
      /**
       * @description Unknown
       * @default 7168
       */
      clientReservedPlayerBPS: number;
      /**
       * @description Unknown
       * @default 15
       */
      clientSentCountAllowance: number;
      /** @description VRChat's contact email */
      contactEmail: string;
      /** @description VRChat's copyright-issues-related email */
      copyrightEmail: string;
      /**
       * @description Current version number of the Terms of Service
       * @example 7
       */
      currentTOSVersion: number;
      defaultAvatar: components["schemas"]["AvatarID"];
      deploymentGroup: components["schemas"]["DeploymentGroup"];
      /**
       * @deprecated
       * @description Version number for game development build
       */
      devAppVersionStandalone: string;
      /**
       * @deprecated
       * @description Developer Download link
       */
      devDownloadLinkWindows: string;
      /**
       * @deprecated
       * @description Link to download the development SDK, use downloadUrls instead
       */
      devSdkUrl: string;
      /**
       * @deprecated
       * @description Version of the development SDK
       */
      devSdkVersion: string;
      /**
       * @deprecated
       * @description Version number for server development build
       */
      devServerVersionStandalone: string;
      /**
       * Format: date-time
       * @description Unknown, "dis" maybe for disconnect?
       */
      "dis-countdown": string;
      /**
       * @description Toggles if copying avatars should be disabled
       * @default false
       */
      disableAvatarCopying: boolean;
      /**
       * @description Toggles if avatar gating should be disabled. Avatar gating restricts uploading of avatars to people with the `system_avatar_access` Tag or `admin_avatar_access` Tag
       * @default false
       */
      disableAvatarGating: boolean;
      /**
       * @description Toggles if the Community Labs should be disabled
       * @default false
       */
      disableCommunityLabs: boolean;
      /**
       * @description Toggles if promotion out of Community Labs should be disabled
       * @default false
       */
      disableCommunityLabsPromotion: boolean;
      /**
       * @description Unknown
       * @default false
       */
      disableEmail: boolean;
      /**
       * @description Toggles if Analytics should be disabled.
       * @default false
       */
      disableEventStream: boolean;
      /**
       * @description Toggles if feedback gating should be disabled. Feedback gating restricts submission of feedback (reporting a World or User) to people with the `system_feedback_access` Tag.
       * @default false
       */
      disableFeedbackGating: boolean;
      /**
       * @description Unknown, probably toggles compilation of frontend web builds? So internal flag?
       * @default false
       */
      disableFrontendBuilds: boolean;
      /**
       * @description Unknown
       * @default false
       */
      disableHello: boolean;
      /**
       * @description Toggles if signing up for Subscriptions in Oculus is disabled or not.
       * @default false
       */
      disableOculusSubs: boolean;
      /**
       * @description Toggles if new user account registration should be disabled.
       * @default false
       */
      disableRegistration: boolean;
      /**
       * @description Toggles if Steam Networking should be disabled. VRChat these days uses Photon Unity Networking (PUN) instead.
       * @default true
       */
      disableSteamNetworking: boolean;
      /**
       * @deprecated
       * @description Toggles if 2FA should be disabled.
       * @default false
       */
      disableTwoFactorAuth: boolean;
      /**
       * @description Toggles if Udon should be universally disabled in-game.
       * @default false
       */
      disableUdon: boolean;
      /**
       * @description Toggles if account upgrading "linking with Steam/Oculus" should be disabled.
       * @default false
       */
      disableUpgradeAccount: boolean;
      /** @description Download link for game on the Oculus Rift website. */
      downloadLinkWindows: string;
      downloadUrls: components["schemas"]["APIConfigDownloadURLList"];
      /** @description Array of DynamicWorldRow objects, used by the game to display the list of world rows */
      dynamicWorldRows: components["schemas"]["DynamicContentRow"][];
      events: components["schemas"]["APIConfigEvents"];
      /**
       * @deprecated
       * @description Unknown
       */
      gearDemoRoomId: string;
      homeWorldId: components["schemas"]["WorldID"];
      /**
       * @description Redirect target if you try to open the base API domain in your browser
       * @default https://hello.vrchat.com
       */
      homepageRedirectTarget: string;
      hubWorldId: components["schemas"]["WorldID"];
      /** @description VRChat's job application email */
      jobsEmail: string;
      /**
       * @deprecated
       * @description MOTD
       */
      messageOfTheDay: string;
      /** @description VRChat's moderation related email */
      moderationEmail: string;
      /** @description Unknown */
      moderationQueryPeriod: number;
      /** @description Used in-game to notify a user they aren't allowed to select avatars in private worlds */
      notAllowedToSelectAvatarInPrivateWorldMessage: string;
      /** @description Extra [plugin](https://doc.photonengine.com/en-us/server/current/plugins/manual) to run in each instance */
      plugin: string;
      /**
       * @deprecated
       * @description Version number for game release build
       */
      releaseAppVersionStandalone: string;
      /**
       * @deprecated
       * @description Link to download the release SDK
       */
      releaseSdkUrl: string;
      /**
       * @deprecated
       * @description Version of the release SDK
       */
      releaseSdkVersion: string;
      /**
       * @deprecated
       * @description Version number for server release build
       */
      releaseServerVersionStandalone: string;
      /** @description Link to the developer FAQ */
      sdkDeveloperFaqUrl: string;
      /** @description Link to the official VRChat Discord */
      sdkDiscordUrl: string;
      /** @description Used in the SDK to notify a user they aren't allowed to upload avatars/worlds yet */
      sdkNotAllowedToPublishMessage: string;
      /** @description Unity version supported by the SDK */
      sdkUnityVersion: string;
      /** @description Server name of the API server currently responding */
      serverName: string;
      /** @description VRChat's support email */
      supportEmail: string;
      timeOutWorldId: components["schemas"]["WorldID"];
      tutorialWorldId: components["schemas"]["WorldID"];
      /** @description Unknown */
      updateRateMsMaximum: number;
      /** @description Unknown */
      updateRateMsMinimum: number;
      /** @description Unknown */
      updateRateMsNormal: number;
      /** @description Unknown */
      updateRateMsUdonManual: number;
      /** @description Unknown */
      uploadAnalysisPercent: number;
      /** @description List of allowed URLs that bypass the "Allow untrusted URL's" setting in-game */
      urlList: string[];
      /**
       * @description Unknown
       * @default false
       */
      useReliableUdpForVoice: boolean;
      /** @description Unknown */
      userUpdatePeriod: number;
      /** @description Unknown */
      userVerificationDelay: number;
      /** @description Unknown */
      userVerificationRetry: number;
      /** @description Unknown */
      userVerificationTimeout: number;
      /** @description Download link for game on the Steam website. */
      viveWindowsUrl: string;
      /** @description List of allowed URLs that are allowed to host avatar assets */
      whiteListedAssetUrls: string[];
      /** @description Unknown */
      worldUpdatePeriod: number;
      /** @description Currently used youtube-dl.exe hash in SHA-256-delimited format */
      "player-url-resolver-hash": string;
      /** @description Currently used youtube-dl.exe version */
      "player-url-resolver-version": string;
    };
    /** InfoPushDataClickable */
    InfoPushDataClickable: {
      /**
       * @example OpenURL
       * @enum {string}
       */
      command: "OpenURL" | "OpenVRCPlusMenu" | "OpenSafetyMenu" | "CannedWorldSearch";
      /** @description In case of OpenURL, this would contain the link. */
      parameters?: string[];
    };
    /** InfoPushDataArticleContent */
    InfoPushDataArticleContent: {
      text?: string;
      imageUrl?: string;
      onPressed?: components["schemas"]["InfoPushDataClickable"];
    };
    /** InfoPushDataArticle */
    InfoPushDataArticle: {
      content?: components["schemas"]["InfoPushDataArticleContent"];
    };
    /** InfoPushData */
    InfoPushData: {
      contentList?: components["schemas"]["DynamicContentRow"];
      description?: string;
      imageUrl?: string;
      name?: string;
      onPressed?: components["schemas"]["InfoPushDataClickable"];
      template?: string;
      /** @example 2021.3.4 */
      version?: string;
      article?: components["schemas"]["InfoPushDataArticle"];
    };
    /** InfoPush */
    InfoPush: {
      /** @example launch-beta */
      id: string;
      /** @default true */
      isEnabled: boolean;
      releaseStatus: components["schemas"]["ReleaseStatus"];
      priority: number;
      /** @description */
      tags: components["schemas"]["Tag"][];
      data: components["schemas"]["InfoPushData"];
      /** @description Unknown usage, MD5 */
      hash: string;
      /** Format: date-time */
      createdAt: string;
      /** Format: date-time */
      updatedAt: string;
      /** Format: date-time */
      startDate?: string;
      /** Format: date-time */
      endDate?: string;
    };
    /** APIHealth */
    APIHealth: {
      ok: boolean;
      serverName: string;
      buildVersionTag: string;
    };
    /** User */
    User: {
      /** @default true */
      allowAvatarCopying: boolean;
      bio: string;
      bioLinks: string[];
      currentAvatarImageUrl: components["schemas"]["CurrentAvatarImageUrl"];
      currentAvatarThumbnailImageUrl: components["schemas"]["CurrentAvatarThumbnailImageUrl"];
      /** Format: date */
      date_joined: string;
      developerType: components["schemas"]["DeveloperType"];
      /** @description A users visual display name. This is what shows up in-game, and can different from their `username`. Changing display name is restricted to a cooldown period. */
      displayName: string;
      friendKey: string;
      friendRequestStatus?: string;
      id: components["schemas"]["UserID"];
      instanceId?: components["schemas"]["InstanceID"];
      /** @description Either their `friendKey`, or empty string if you are not friends. Unknown usage. */
      isFriend: boolean;
      /** @description Either a date-time or empty string. */
      last_activity: string;
      /** @description Either a date-time or empty string. */
      last_login: string;
      last_platform: components["schemas"]["Platform"];
      location?: components["schemas"]["WorldID"];
      note?: string;
      profilePicOverride: string;
      state: components["schemas"]["UserState"];
      status: components["schemas"]["UserStatus"];
      statusDescription: string;
      /** @description */
      tags: components["schemas"]["Tag"][];
      travelingToInstance?: string;
      travelingToLocation?: string;
      travelingToWorld?: string;
      userIcon: string;
      /**
       * @deprecated
       * @description -| A users unique name, used during login. This is different from `displayName` which is what shows up in-game. A users `username` can never be changed.'
       * **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429).
       */
      username?: string;
      worldId?: components["schemas"]["WorldID"];
    };
    /** UpdateUserRequest */
    UpdateUserRequest: {
      email?: string;
      /** Format: date */
      birthday?: string;
      acceptedTOSVersion?: number;
      /** @description */
      tags?: components["schemas"]["Tag"][];
      status?: components["schemas"]["UserStatus"];
      statusDescription?: string;
      bio?: string;
      bioLinks?: string[];
      /**
       * @description MUST be a valid VRChat /file/ url.
       * @example https://api.vrchat.cloud/api/1/file/file_76dc2964-0ce8-41df-b2e7-8edf994fee31/1
       */
      userIcon?: string;
    };
    /** LimitedUnityPackage */
    LimitedUnityPackage: {
      platform: components["schemas"]["Platform"];
      /** @example 2018.4.14f1 */
      unityVersion: string;
    };
    /** LimitedWorld */
    LimitedWorld: {
      authorId: components["schemas"]["UserID"];
      authorName: string;
      /** @example 8 */
      capacity: number;
      /** Format: date-time */
      created_at: string;
      /**
       * @default 0
       * @example 12024
       */
      favorites: number;
      /**
       * @default 0
       * @example 5
       */
      heat: number;
      id: components["schemas"]["WorldID"];
      imageUrl: string;
      /** @example none */
      labsPublicationDate: string;
      name: string;
      /**
       * @default 0
       * @example 47
       */
      occupants: number;
      /** @default vrchat */
      organization: string;
      /**
       * @default 0
       * @example 8
       */
      popularity: number;
      /** @example none */
      publicationDate: string;
      releaseStatus: components["schemas"]["ReleaseStatus"];
      /** @description */
      tags: components["schemas"]["Tag"][];
      thumbnailImageUrl: string;
      /** @description */
      unityPackages: components["schemas"]["LimitedUnityPackage"][];
      /** Format: date-time */
      updated_at: string;
    };
    /** CreateWorldRequest */
    CreateWorldRequest: {
      assetUrl: string;
      assetVersion?: number;
      authorId?: components["schemas"]["UserID"];
      authorName?: string;
      /** @example 8 */
      capacity?: number;
      description?: string;
      id?: components["schemas"]["WorldID"];
      imageUrl: string;
      name: string;
      platform?: components["schemas"]["Platform"];
      releaseStatus?: components["schemas"]["ReleaseStatus"];
      /** @description */
      tags?: components["schemas"]["Tag"][];
      unityPackageUrl?: string;
      /**
       * @default 5.3.4p1
       * @example 2018.4.20f1
       */
      unityVersion?: string;
    };
    /** World */
    World: {
      authorId: components["schemas"]["UserID"];
      authorName: string;
      /** @example 8 */
      capacity: number;
      /** @example 4 */
      recommendedCapacity: number;
      /** Format: date-time */
      created_at: string;
      description: string;
      /**
       * @default 0
       * @example 12024
       */
      favorites?: number;
      /** @default false */
      featured: boolean;
      /**
       * @default 0
       * @example 5
       */
      heat: number;
      id: components["schemas"]["WorldID"];
      imageUrl: string;
      /** @description Will always be an empty list when unauthenticated. */
      instances?: unknown[][];
      /** @example none */
      labsPublicationDate: string;
      name: string;
      namespace: string;
      /**
       * @description Will always be `0` when unauthenticated.
       * @default 0
       * @example 47
       */
      occupants?: number;
      /** @default vrchat */
      organization: string;
      /**
       * @default 0
       * @example 8
       */
      popularity: number;
      previewYoutubeId?: string | null;
      /**
       * @description Will always be `0` when unauthenticated.
       * @default 0
       * @example 1
       */
      privateOccupants?: number;
      /**
       * @description Will always be `0` when unauthenticated.
       * @default 0
       * @example 46
       */
      publicOccupants?: number;
      /** @example none */
      publicationDate: string;
      releaseStatus: components["schemas"]["ReleaseStatus"];
      /** @description */
      tags: components["schemas"]["Tag"][];
      thumbnailImageUrl: string;
      /** @description Empty if unauthenticated. */
      unityPackages?: components["schemas"]["UnityPackage"][];
      /** Format: date-time */
      updated_at: string;
      /**
       * @default 0
       * @example 68
       */
      version: number;
      /**
       * @default 0
       * @example 9988675
       */
      visits: number;
    };
    /** UpdateWorldRequest */
    UpdateWorldRequest: {
      assetUrl?: string;
      assetVersion?: string;
      authorId?: components["schemas"]["UserID"];
      authorName?: string;
      /** @example 8 */
      capacity?: number;
      description?: string;
      imageUrl?: string;
      name?: string;
      platform?: components["schemas"]["Platform"];
      releaseStatus?: components["schemas"]["ReleaseStatus"];
      /** @description */
      tags?: components["schemas"]["Tag"][];
      unityPackageUrl?: string;
      /**
       * @default 5.3.4p1
       * @example 2018.4.20f1
       */
      unityVersion?: string;
    };
    /** WorldMetadata */
    WorldMetadata: {
      id: components["schemas"]["WorldID"];
      metadata: Record<string, never>;
    };
    /** WorldPublishStatus */
    WorldPublishStatus: {
      /** @default true */
      canPubilsh: boolean;
    };
  };
  responses: {
    /** @description Returns a response if a user exists or not. */
    UserExistsResponse: {
      content: {
        "application/json": components["schemas"]["UserExists"];
      };
    };
    /** @description Error response when missing at least 1 of the required parameters. */
    MissingParameterError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description OK */
    CurrentUserLoginResponse: {
      headers: {
        /** @description Successful authentication returns an `auth` cookie. */
        "Set-Cookie"?: string;
      };
      content: {
        "application/json": components["schemas"]["CurrentUser"];
      };
    };
    /** @description Error response due to missing auth cookie. */
    MissingCredentialsError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description OK */
    Verify2FAResponse: {
      headers: {
        /** @description Provides a `twoFactorAuth` cookie, which can be used to bypasses the 2FA requirement for future logins on the same device. */
        "Set-Cookie"?: string;
      };
      content: {
        "application/json": components["schemas"]["Verify2FAResult"];
      };
    };
    /** @description OK */
    Verify2FAEmailCodeResponse: {
      headers: {
        /** @description Provides a `twoFactorAuth` cookie, which can be used to bypasses the 2FA requirement for future logins on the same device. */
        "Set-Cookie"?: string;
      };
      content: {
        "application/json": components["schemas"]["Verify2FAEmailCodeResult"];
      };
    };
    /** @description Returns wether a provided auth token is valid or not. */
    VerifyAuthTokenResponse: {
      content: {
        "application/json": components["schemas"]["VerifyAuthTokenResult"];
      };
    };
    /** @description OK */
    LogoutSuccess: {
      headers: {
        /** @description Clears the `auth` cookie. */
        "Set-Cookie"?: string;
        /** @description Clears the `age` cookie. */
        "\0Set-Cookie"?: string;
        /** @description Clears the `tos` cookie. */
        "\0\0Set-Cookie"?: string;
      };
      content: {
        "application/json": components["schemas"]["Success"];
      };
    };
    /** @description OK */
    DeleteUserResponse: {
      content: {
        "application/json": components["schemas"]["CurrentUser"];
      };
    };
    /** @description Returns a single Avatar object. */
    AvatarResponse: {
      content: {
        "application/json": components["schemas"]["Avatar"];
      };
    };
    /** @description Error response when trying to see another users current avatar without sufficient admin permissions. */
    AvatarSeeOtherUserCurrentAvatarError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Returns a list of Avatar objects. */
    AvatarListResponse: {
      content: {
        "application/json": components["schemas"]["Avatar"][];
      };
    };
    /** @description Error response when set featured to true without being an admin. */
    FeaturedSetNotAdminError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Error response when trying to show information about a non-existent avatar. */
    AvatarNotFoundError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Returns a single CurrentUser object. */
    CurrentUserResponse: {
      content: {
        "application/json": components["schemas"]["CurrentUser"];
      };
    };
    /** @description Error response when trying to select a fallback avatar that is missing the fallback tag. */
    AvatarNotTaggedAsFallbackError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Error response when trying to see favourited avatars of another user without sufficient admin permissions. */
    AvatarSeeOtherUserFavoritesError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Returns a list of Transaction objects. */
    TransactionListResponse: {
      content: {
        "application/json": components["schemas"]["Transaction"][];
      };
    };
    /** @description Returns a single Transaction object. */
    TransactionResponse: {
      content: {
        "application/json": components["schemas"]["Transaction"];
      };
    };
    /** @description Returns a list of UserSubscription objects. */
    UserSubscriptionListResponse: {
      content: {
        "application/json": components["schemas"]["UserSubscription"][];
      };
    };
    /** @description Returns a list of Subscription objects. */
    SubscriptionListResponse: {
      content: {
        "application/json": components["schemas"]["Subscription"][];
      };
    };
    /** @description Returns a list of LicenseGroup objects. */
    LicenseGroupListResponse: {
      content: {
        "application/json": components["schemas"]["LicenseGroup"][];
      };
    };
    /** @description Returns a single LicenseGroup object. */
    LicenseGroupResponse: {
      content: {
        "application/json": components["schemas"]["LicenseGroup"];
      };
    };
    /** @description Returns a list of Favorite objects. */
    FavoriteListResponse: {
      content: {
        "application/json": components["schemas"]["Favorite"][];
      };
    };
    /** @description Returns a single Favorite object. */
    FavoriteResponse: {
      content: {
        "application/json": components["schemas"]["Favorite"];
      };
    };
    /** @description Error response when trying favorite someone or something when already having it/them favorited. */
    FavoriteAddAlreadyFavoritedError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Error response when trying favorite someone whom you are not friends with. */
    FavoriteAddNotFriendsError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Error response when trying to show information about a non-existent favorite. */
    FavoriteNotFoundError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Success response after removing a favorite. */
    FavoriteRemovedSuccess: {
      content: {
        "application/json": components["schemas"]["Success"];
      };
    };
    /** @description Returns a list of FavoriteGroup objects. */
    FavoriteGroupListResponse: {
      content: {
        "application/json": components["schemas"]["FavoriteGroup"][];
      };
    };
    /** @description Returns a single FavoriteGroup object. */
    FavoriteGroupResponse: {
      content: {
        "application/json": components["schemas"]["FavoriteGroup"];
      };
    };
    /** @description Success response after clearing a favorite group. */
    FavoriteGroupClearedSuccess: {
      content: {
        "application/json": components["schemas"]["Success"];
      };
    };
    /** @description Returns a list of File objects. */
    FileListResponse: {
      content: {
        "application/json": components["schemas"]["File"][];
      };
    };
    /** @description Returns a single File object. */
    FileResponse: {
      content: {
        "application/json": components["schemas"]["File"];
      };
    };
    /** @description Error response when trying to show information about a non-existent file. */
    FileNotFoundError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Successful response after deleting a File. */
    FileDeletedSuccess: {
      content: {
        "application/json": components["schemas"]["Success"];
      };
    };
    /** @description Error response when trying to delete a non-existent file. */
    FileDeletedError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Raw file */
    RawFileResponse: {
      content: never;
    };
    /** @description Error response when trying to delete the initial version of a file. Delete the main File object instead. */
    FileVersionDeleteInitialError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Error response when trying to delete any version of a file that is not hte last one. */
    FileVersionDeleteMiddleError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description See [https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutObject.html](AWS REST docs - PUT Object) */
    FileUploadURLResponse: {
      content: {
        "application/json": components["schemas"]["FileUploadURL"];
      };
    };
    /** @description Error response when trying to start an upload against a FileVersion that is already marked as  `complete`. */
    FileUploadAlreadyFinishedError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Current FileVersion upload status. Contains the uploadId needed for uploading, as well as the already uploaded parts. */
    FileVersionUploadStatusResponse: {
      content: {
        "application/json": components["schemas"]["FileVersionUploadStatus"];
      };
    };
    /** @description Returns a list of LimitedUser objects. */
    LimitedUserListResponse: {
      content: {
        "application/json": components["schemas"]["LimitedUser"][];
      };
    };
    /** @description Returns a single Notifcation object. */
    NotificationResponse: {
      content: {
        "application/json": components["schemas"]["Notification"];
      };
    };
    /** @description Error response when trying to send a friend request to a user which doesn't exist. */
    UserDoesntExistError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Successful response after cancelling a friend request. */
    DeleteFriendSuccess: {
      content: {
        "application/json": components["schemas"]["Success"];
      };
    };
    /** @description Error response when trying to delete a non-existent friend-request. */
    DeleteFriendRequestError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Returns a users Friend Status. */
    FriendStatusResponse: {
      content: {
        "application/json": components["schemas"]["FriendStatus"];
      };
    };
    /** @description Successful response after unfriending a user. */
    UnfriendSuccess: {
      content: {
        "application/json": components["schemas"]["Success"];
      };
    };
    /** @description Error response when trying to unfriend someone who is not a friend. */
    NotFriendsError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Returns a single Group object. */
    GroupResponse: {
      content: {
        "application/json": components["schemas"]["Group"];
      };
    };
    /** @description Error response when trying to perform operations on a non-existing group. */
    GroupNotFoundError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Successful response after deleting a Group. */
    DeleteGroupSuccess: {
      content: {
        "application/json": components["schemas"]["Success"];
      };
    };
    /** @description Returns a single GroupAnnouncement object. */
    GroupAnnouncementResponse: {
      content: {
        "application/json": components["schemas"]["GroupAnnouncement"];
      };
    };
    /** @description Successful response after deleting/clearing the group announcement. */
    DeleteGroupAnnouncementSuccess: {
      content: {
        "application/json": components["schemas"]["Success"];
      };
    };
    /** @description Returns a list of GroupAudit objects, wrapped in new pagination format. */
    GroupAuditLogListResponse: {
      content: {
        "application/json": components["schemas"]["PaginatedGroupAuditLogEntryList"];
      };
    };
    /** @description Returns a list of GroupMember objects. */
    GroupMemberListResponse: {
      content: {
        "application/json": components["schemas"]["GroupMember"][];
      };
    };
    /** @description Returns a list of GroupMember objects. */
    GroupMemberResponse: {
      content: {
        "application/json": components["schemas"]["GroupMember"];
      };
    };
    /** @description Returns a single GroupGallery object. */
    GroupGalleryResponse: {
      content: {
        "application/json": components["schemas"]["GroupGallery"];
      };
    };
    /** @description Returns a list of GroupGalleryImage objects. */
    GroupGalleryImageListResponse: {
      content: {
        "application/json": components["schemas"]["GroupGalleryImage"][];
      };
    };
    /** @description Successful response after deleting a group gallery. */
    DeleteGroupGallerySuccess: {
      content: {
        "application/json": components["schemas"]["Success"];
      };
    };
    /** @description Returns a single GroupGalleryImage object. */
    GroupGalleryImageResponse: {
      content: {
        "application/json": components["schemas"]["GroupGalleryImage"];
      };
    };
    /** @description Successful response after deleting a group gallery image. */
    DeleteGroupGalleryImageSuccess: {
      content: {
        "application/json": components["schemas"]["Success"];
      };
    };
    /** @description Error response when trying to delete a submission to a group's gallery when the user does not have permission to do so. */
    GroupGalleryImageDeleteForbiddenError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Error response when trying to perform operations on a group you are not member of. */
    GroupNotMemberError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Error response when trying to join a group that the user is already a member of. */
    GroupAlreadyMemberError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Error response when trying to search list of users with an invalid request. */
    UsersInvalidSearchError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Returns a list of GroupMember objects. */
    GroupLimitedMemberResponse: {
      content: {
        "application/json": components["schemas"]["GroupLimitedMember"];
      };
    };
    /** @description Returns a list of GroupRoleID objects. */
    GroupRoleIDListResponse: {
      content: {
        "application/json": components["schemas"]["GroupRoleIDList"];
      };
    };
    /** @description Returns a list of GroupPermission objects. */
    GroupPermissionListResponse: {
      content: {
        "application/json": components["schemas"]["GroupPermission"][];
      };
    };
    /** @description Returns a list of GroupRole objects. */
    GroupRoleListResponse: {
      content: {
        "application/json": components["schemas"]["GroupRole"][];
      };
    };
    /** @description Returns a single GroupRole object. */
    GroupRoleResponse: {
      content: {
        "application/json": components["schemas"]["GroupRole"];
      };
    };
    /** @description Returns a single SentNotifcation object. */
    SendNotificationResponse: {
      content: {
        "application/json": components["schemas"]["SentNotification"];
      };
    };
    /** @description Error response when trying to invite someome whom you are not friends with. */
    InviteMustBeFriendsError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Error response due to non existant instance */
    InstanceNotFoundError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Error response when trying to respond to an invite and something went wrong. */
    InviteResponse400Error: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Returns a list of InviteMessage objects. */
    InviteMessageListResponse: {
      content: {
        "application/json": components["schemas"]["InviteMessage"][];
      };
    };
    /** @description Error response when trying to update an Invite Message with an invalid slot number. */
    InviteMessageInvalidSlotNumberError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Error response due to missing authorization to perform that action. */
    NotAuthorizedActionError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Returns a single InviteMessage object. */
    InviteMessageResponse: {
      content: {
        "application/json": components["schemas"]["InviteMessage"];
      };
    };
    /** @description Error response when trying to get an Invite Message with a negative slot number. */
    InviteMessageGetNegativeSlotError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Error response when trying to get an Invite Message with a too high slot number. */
    InviteMessageGetTooHighSlotError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Error response when trying to update an Invite Message before the cooldown has expired. */
    InviteMessageUpdateRateLimitError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Error response when trying to reset an Invite Message whos slot doesn't exist. */
    InviteMessageNoEntryForSlotError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Returns a single Instance object. */
    InstanceResponse: {
      content: {
        "application/json": components["schemas"]["Instance"];
      };
    };
    /** @description Returns an instance secureName and/or shortName. */
    InstanceShortNameResponse: {
      content: {
        "text/plain": components["schemas"]["InstanceShortNameResponse"];
      };
    };
    /** @description Success response after sending an invite to yourself to the instance. */
    InstanceSelfInviteSuccess: {
      content: {
        "application/json": components["schemas"]["Success"];
      };
    };
    /** @description Returns a list of Notifcation objects. */
    NotificationListResponse: {
      content: {
        "application/json": components["schemas"]["Notification"][];
      };
    };
    /** @description Successful response after friending a user. */
    FriendSuccess: {
      content: {
        "application/json": components["schemas"]["Success"];
      };
    };
    /** @description Error response when trying to accept a non-existent friend request. */
    AcceptFriendRequestError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Successful response after clearing all notifications. */
    ClearNotificationsSuccess: {
      content: {
        "application/json": components["schemas"]["Success"];
      };
    };
    /** @description Returns a list of Permission objects. */
    PermissionListResponse: {
      content: {
        "application/json": components["schemas"]["Permission"][];
      };
    };
    /** @description Error response due to missing Administrator credentials. */
    InvalidAdminCredentialsError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Returns a single Permission object. */
    PermissionResponse: {
      content: {
        "application/json": components["schemas"]["Permission"];
      };
    };
    /** @description Returns a list of PlayerModeration objects. */
    PlayerModerationListResponse: {
      content: {
        "application/json": components["schemas"]["PlayerModeration"][];
      };
    };
    /** @description Returns a single PlayerModeration object. */
    PlayerModerationResponse: {
      content: {
        "application/json": components["schemas"]["PlayerModeration"];
      };
    };
    /** @description Success response after e.g. clearing all player moderations. */
    PlayerModerationClearAllSuccess: {
      content: {
        "application/json": components["schemas"]["Success"];
      };
    };
    /** @description Error response when trying to show information about a non-existent player moderation. */
    PlayerModerationNotFoundError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Success response after removing a PlayerModeration by ID. */
    PlayerModerationRemovedSuccess: {
      content: {
        "application/json": components["schemas"]["Success"];
      };
    };
    /** @description Error response when trying to delete someone else's player moderation. */
    PlayerModerationDeleteOthersError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Success response after unmoderating a player moderation. */
    PlayerModerationUnmoderatedSuccess: {
      content: {
        "application/json": components["schemas"]["Success"];
      };
    };
    /** @description Returns the API's config. */
    APIConfigResponse: {
      content: {
        "application/json": components["schemas"]["APIConfig"];
      };
    };
    /** @description Returns a list of InfoPush objects. */
    InfoPushListResponse: {
      content: {
        "application/json": components["schemas"]["InfoPush"][];
      };
    };
    /** @description Error response when trying to download non-public and non-main JavaScript or CSS without Admin Credentials. */
    DownloadSourceCodeAccessError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Returns the API's health. */
    APIHealthResponse: {
      content: {
        "application/json": components["schemas"]["APIHealth"];
      };
    };
    /** @description OK */
    CurrentOnlineUsersResponse: {
      content: {
        "application/json": number;
      };
    };
    /** @description OK */
    SystemTimeResponse: {
      content: {
        "application/json": string;
      };
    };
    /** @description Returns a single User object. */
    UserResponse: {
      content: {
        "application/json": components["schemas"]["User"];
      };
    };
    /** @description Returns a list of Group objects. */
    GroupListResponse: {
      content: {
        "application/json": components["schemas"]["Group"][];
      };
    };
    /** @description Returns a list of LimitedWorld objects. */
    LimitedWorldListResponse: {
      content: {
        "application/json": components["schemas"]["LimitedWorld"][];
      };
    };
    /** @description Returns a single World object. */
    WorldResponse: {
      content: {
        "application/json": components["schemas"]["World"];
      };
    };
    /** @description Error response when trying create a world without having the neccesary Trust rank yet. */
    WorldCreateNotAllowedYetError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Error response when trying to see favourited worlds of another user without sufficient admin permissions. */
    WorldSeeOtherUserFavoritesError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Error response when trying to see recently visited worlds of another user without sufficient admin permissions. */
    WorldSeeOtherUserRecentsError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Error response when trying to show information about a non-existent world. Sometimes returns with `model <worldId> not found` instead of `World <worldId not found`. */
    WorldNotFoundError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description OK */
    WorldMetadataResponse: {
      content: {
        "application/json": components["schemas"]["WorldMetadata"];
      };
    };
    /** @description Returns a single WorldPublishStatus object. */
    WorldPublishStatusResponse: {
      content: {
        "application/json": components["schemas"]["WorldPublishStatus"];
      };
    };
  };
  parameters: {
    /** @description Filter by email. */
    email?: string;
    /** @description Filter by displayName. */
    displayName?: string;
    /** @description Filter by UserID. */
    userIdQuery?: string;
    /** @description Exclude by UserID. */
    excludeUserId?: string;
    /** @description Must be a valid user ID. */
    userId: string;
    /** @description Filters on featured results. */
    featured?: boolean;
    /** @description The sort order of the results. */
    sort?: components["schemas"]["SortOption"];
    /** @description The number of objects to return. */
    number?: number;
    /** @description Result ordering */
    order?: components["schemas"]["OrderOption"];
    /** @description A zero-based offset from the default object sorting from where search results start. */
    offset?: number;
    /** @description Tags to include (comma-separated). Any of the tags needs to be present. */
    tag?: string;
    /** @description Tags to exclude (comma-separated). */
    notag?: string;
    /** @description Filter by ReleaseStatus. */
    releaseStatus?: components["schemas"]["ReleaseStatus"];
    /** @description The maximum Unity version supported by the asset. */
    maxUnityVersion?: string;
    /** @description The minimum Unity version supported by the asset. */
    minUnityVersion?: string;
    /** @description The platform the asset supports. */
    platform?: string;
    /** @description Must be a valid avatar ID. */
    avatarId: string;
    /** @description Filters by world name. */
    search?: string;
    /** @description Target user to see information on, admin-only. */
    userIdAdmin?: string;
    /** @description Must be a valid transaction ID. */
    transactionId: string;
    /** @description Must be a valid license group ID. */
    licenseGroupId: string;
    /** @description Must be a valid favorite ID. */
    favoriteId: string;
    /** @description The type of group to fetch, must be a valid FavoriteType. */
    favoriteGroupType: "world" | "friend" | "avatar";
    /** @description The name of the group to fetch, must be a name of a FavoriteGroup. */
    favoriteGroupName: string;
    /** @description Must be a valid file ID. */
    fileId: string;
    /** @description Version ID of the asset. */
    versionId: number;
    /** @description Type of file. */
    fileType: "file" | "signature" | "delta";
    /** @description Returns *only* offline users if true, returns only online and active users if false */
    offline?: boolean;
    /** @description Must be a valid group ID. */
    groupId: string;
    /** @description The start date of the search range. */
    startDate?: string;
    /** @description The end date of the search range. */
    endDate?: string;
    /** @description Must be a valid group gallery ID. */
    groupGalleryId: string;
    /** @description Must be a valid group gallery image ID. */
    groupGalleryImageId: string;
    /** @description Must be a valid group role ID. */
    groupRoleId: string;
    /** @description Must be a valid world ID. */
    worldId: string;
    /** @description Must be a valid instance ID. */
    instanceId: string;
    /** @description Must be a valid notification ID. */
    notificationId: string;
    /** @description The type of message to fetch, must be a valid InviteMessageType. */
    messageType: components["schemas"]["InviteMessageType"];
    /** @description The message slot to fetch of a given message type. */
    slot: number;
    /** @description Must be a valid permission ID. */
    permissionId: string;
    /** @description Tags to include (comma-separated). All of the tags needs to be present. */
    require?: string;
    /** @description Tags to include (comma-separated). Any of the tags needs to be present. */
    include?: string;
    /** @description Specifies which `variant` of the site. Public is the end-user site, while `internal` is the staff-only site with special pages for moderation and management. */
    variant?: "public" | "internal";
    /** @description Specifies which git branch the site should load frontend source code from. */
    branch?: string;
  };
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /**
   * Check User Exists
   * @description Checks if a user by a given `username`, `displayName` or `email` exist. This is used during registration to check if a username has already been taken, during change of displayName to check if a displayName is available, and during change of email to check if the email is already used. In the later two cases the `excludeUserId` is used to exclude oneself, otherwise the result would always be true.
   *
   * It is **REQUIRED** to include **AT LEAST** `username`, `displayName` **or** `email` query parameter. Although they can be combined - in addition with `excludeUserId` (generally to exclude yourself) - to further fine-tune the search.
   */
  checkUserExists: {
    parameters: {
      query?: {
        email?: components["parameters"]["email"];
        displayName?: components["parameters"]["displayName"];
        userId?: components["parameters"]["userIdQuery"];
        excludeUserId?: components["parameters"]["excludeUserId"];
      };
    };
    responses: {
      200: components["responses"]["UserExistsResponse"];
      400: components["responses"]["MissingParameterError"];
    };
  };
  /**
   * Login and/or Get Current User Info
   * @description This endpoint does the following two operations:
   *   1) Checks if you are already logged in by looking for a valid `auth` cookie. If you are have a valid auth cookie then no additional auth-related actions are taken. If you are **not** logged in then it will log you in with the `Authorization` header and set the `auth` cookie. The `auth` cookie will only be sent once.
   *   2) If logged in, this function will also return the CurrentUser object containing detailed information about the currently logged in user.
   *
   * The auth string after `Authorization: Basic {string}` is a base64-encoded string of the username and password, both individually url-encoded, and then joined with a colon.
   *
   * > base64(urlencode(username):urlencode(password))
   *
   * **WARNING: Session Limit:** Each authentication with login credentials counts as a separate session, out of which you have a limited amount. Make sure to save and reuse the `auth` cookie if you are often restarting the program. The provided API libraries automatically save cookies during runtime, but does not persist during restart. While it can be fine to use username/password during development, expect in production to very fast run into the rate-limit and be temporarily blocked from making new sessions until older ones expire. The exact number of simultaneous sessions is unknown/undisclosed.
   */
  getCurrentUser: {
    responses: {
      200: components["responses"]["CurrentUserLoginResponse"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Verify 2FA code
   * @description Finishes the login sequence with a normal 2FA-generated code for accounts with 2FA-protection enabled.
   */
  verify2FA: {
    requestBody?: {
      content: {
        "application/json": components["schemas"]["TwoFactorAuthCode"];
      };
    };
    responses: {
      200: components["responses"]["Verify2FAResponse"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Verify 2FA code with Recovery code
   * @description Finishes the login sequence with an OTP (One Time Password) recovery code for accounts with 2FA-protection enabled.
   */
  verifyRecoveryCode: {
    requestBody?: {
      content: {
        "application/json": components["schemas"]["TwoFactorAuthCode"];
      };
    };
    responses: {
      200: components["responses"]["Verify2FAResponse"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Verify 2FA email code
   * @description Finishes the login sequence with an 2FA email code.
   */
  verify2FAEmailCode: {
    requestBody?: {
      content: {
        "application/json": components["schemas"]["TwoFactorEmailCode"];
      };
    };
    responses: {
      200: components["responses"]["Verify2FAEmailCodeResponse"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Verify Auth Token
   * @description Verify whether the currently provided Auth Token is valid.
   */
  verifyAuthToken: {
    responses: {
      200: components["responses"]["VerifyAuthTokenResponse"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Logout
   * @description Invalidates the login session.
   */
  logout: {
    responses: {
      200: components["responses"]["LogoutSuccess"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Delete User
   * @description Deletes the account with given ID. Normal users only have permission to delete their own account. Account deletion is 14 days from this request, and will be cancelled if you do an authenticated request with the account afterwards.
   *
   * **VRC+ NOTE:** Despite the 14-days cooldown, any VRC+ subscription will be cancelled **immediately**.
   *
   * **METHOD NOTE:** Despite this being a Delete action, the method type required is PUT.
   */
  deleteUser: {
    parameters: {
      path: {
        userId: components["parameters"]["userId"];
      };
    };
    responses: {
      200: components["responses"]["DeleteUserResponse"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Get Own Avatar
   * @description Get the current avatar for the user. This will return an error for any other user than the one logged in.
   */
  getOwnAvatar: {
    parameters: {
      path: {
        userId: components["parameters"]["userId"];
      };
    };
    responses: {
      200: components["responses"]["AvatarResponse"];
      401: components["responses"]["MissingCredentialsError"];
      403: components["responses"]["AvatarSeeOtherUserCurrentAvatarError"];
    };
  };
  /**
   * Search Avatars
   * @description Search and list avatars by query filters. You can only search your own or featured avatars. It is not possible as a normal user to search other peoples avatars.
   */
  searchAvatars: {
    parameters: {
      query?: {
        featured?: components["parameters"]["featured"];
        sort?: components["parameters"]["sort"];
        /** @description Set to `me` for searching own avatars. */
        user?: "me";
        userId?: components["parameters"]["userIdQuery"];
        n?: components["parameters"]["number"];
        order?: components["parameters"]["order"];
        offset?: components["parameters"]["offset"];
        tag?: components["parameters"]["tag"];
        notag?: components["parameters"]["notag"];
        releaseStatus?: components["parameters"]["releaseStatus"];
        maxUnityVersion?: components["parameters"]["maxUnityVersion"];
        minUnityVersion?: components["parameters"]["minUnityVersion"];
        platform?: components["parameters"]["platform"];
      };
    };
    responses: {
      200: components["responses"]["AvatarListResponse"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Create Avatar
   * @description Create an avatar. It's possible to optionally specify a ID if you want a custom one. Attempting to create an Avatar with an already claimed ID will result in a DB error.
   */
  createAvatar: {
    requestBody?: {
      content: {
        "application/json": components["schemas"]["CreateAvatarRequest"];
      };
    };
    responses: {
      200: components["responses"]["AvatarResponse"];
      401: components["responses"]["FeaturedSetNotAdminError"];
    };
  };
  /**
   * Get Avatar
   * @description Get information about a specific Avatar.
   */
  getAvatar: {
    parameters: {
      path: {
        avatarId: components["parameters"]["avatarId"];
      };
    };
    responses: {
      200: components["responses"]["AvatarResponse"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["AvatarNotFoundError"];
    };
  };
  /**
   * Update Avatar
   * @description Update information about a specific avatar.
   */
  updateAvatar: {
    parameters: {
      path: {
        avatarId: components["parameters"]["avatarId"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["UpdateAvatarRequest"];
      };
    };
    responses: {
      200: components["responses"]["AvatarResponse"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["AvatarNotFoundError"];
    };
  };
  /**
   * Delete Avatar
   * @description Delete an avatar. Notice an avatar is never fully "deleted", only its ReleaseStatus is set to "hidden" and the linked Files are deleted. The AvatarID is permanently reserved.
   */
  deleteAvatar: {
    parameters: {
      path: {
        avatarId: components["parameters"]["avatarId"];
      };
    };
    responses: {
      200: components["responses"]["AvatarResponse"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["AvatarNotFoundError"];
    };
  };
  /**
   * Select Avatar
   * @description Switches into that avatar.
   */
  selectAvatar: {
    parameters: {
      path: {
        avatarId: components["parameters"]["avatarId"];
      };
    };
    responses: {
      200: components["responses"]["CurrentUserResponse"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["AvatarNotFoundError"];
    };
  };
  /**
   * Select Fallback Avatar
   * @description Switches into that avatar as your fallback avatar.
   */
  selectFallbackAvatar: {
    parameters: {
      path: {
        avatarId: components["parameters"]["avatarId"];
      };
    };
    responses: {
      200: components["responses"]["CurrentUserResponse"];
      401: components["responses"]["MissingCredentialsError"];
      403: components["responses"]["AvatarNotTaggedAsFallbackError"];
      404: components["responses"]["AvatarNotFoundError"];
    };
  };
  /**
   * List Favorited Avatars
   * @description Search and list favorited avatars by query filters.
   */
  getFavoritedAvatars: {
    parameters: {
      query?: {
        featured?: components["parameters"]["featured"];
        sort?: components["parameters"]["sort"];
        n?: components["parameters"]["number"];
        order?: components["parameters"]["order"];
        offset?: components["parameters"]["offset"];
        search?: components["parameters"]["search"];
        tag?: components["parameters"]["tag"];
        notag?: components["parameters"]["notag"];
        releaseStatus?: components["parameters"]["releaseStatus"];
        maxUnityVersion?: components["parameters"]["maxUnityVersion"];
        minUnityVersion?: components["parameters"]["minUnityVersion"];
        platform?: components["parameters"]["platform"];
        userId?: components["parameters"]["userIdAdmin"];
      };
    };
    responses: {
      200: components["responses"]["AvatarListResponse"];
      401: components["responses"]["MissingCredentialsError"];
      403: components["responses"]["AvatarSeeOtherUserFavoritesError"];
    };
  };
  /**
   * List Steam Transactions
   * @description Get all own Steam transactions.
   */
  getSteamTransactions: {
    responses: {
      200: components["responses"]["TransactionListResponse"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Get Steam Transaction
   * @deprecated
   * @description Get a single Steam transactions by ID. This returns the exact same information as `getSteamTransactions`, so no point in using this endpoint.
   */
  getSteamTransaction: {
    parameters: {
      path: {
        transactionId: components["parameters"]["transactionId"];
      };
    };
    responses: {
      200: components["responses"]["TransactionResponse"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Get Current Subscriptions
   * @description Get a list of all current user subscriptions.
   */
  getCurrentSubscriptions: {
    responses: {
      200: components["responses"]["UserSubscriptionListResponse"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * List Subscriptions
   * @description List all existing Subscriptions. For example, "vrchatplus-monthly" and "vrchatplus-yearly".
   */
  getSubscriptions: {
    responses: {
      200: components["responses"]["SubscriptionListResponse"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Get License Group
   * @description Get a single License Group by given ID.
   */
  getLicenseGroup: {
    parameters: {
      path: {
        licenseGroupId: components["parameters"]["licenseGroupId"];
      };
    };
    responses: {
      200: components["responses"]["LicenseGroupResponse"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * List Favorites
   * @description Returns a list of favorites.
   */
  getFavorites: {
    parameters: {
      query?: {
        n?: components["parameters"]["number"];
        offset?: components["parameters"]["offset"];
        /** @description The type of favorites to return, FavoriteType. */
        type?: string;
        tag?: components["parameters"]["tag"];
      };
    };
    responses: {
      200: components["responses"]["FavoriteListResponse"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Add Favorite
   * @description Add a new favorite.
   *
   * Friend groups are named `group_0` through `group_3`. Avatar and World groups are named `avatars1` to `avatars4` and `worlds1` to `worlds4`.
   *
   * You cannot add people whom you are not friends with to your friends list. Destroying a friendship removes the person as favorite on both sides.
   */
  addFavorite: {
    requestBody?: {
      content: {
        "application/json": components["schemas"]["AddFavoriteRequest"];
      };
    };
    responses: {
      200: components["responses"]["FavoriteResponse"];
      400: components["responses"]["FavoriteAddAlreadyFavoritedError"];
      403: components["responses"]["FavoriteAddNotFriendsError"];
    };
  };
  /**
   * Show Favorite
   * @description Return information about a specific Favorite.
   */
  getFavorite: {
    parameters: {
      path: {
        favoriteId: components["parameters"]["favoriteId"];
      };
    };
    responses: {
      200: components["responses"]["FavoriteResponse"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["FavoriteNotFoundError"];
    };
  };
  /**
   * Remove Favorite
   * @description Remove a favorite from your favorites list.
   */
  removeFavorite: {
    parameters: {
      path: {
        favoriteId: components["parameters"]["favoriteId"];
      };
    };
    responses: {
      200: components["responses"]["FavoriteRemovedSuccess"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["FavoriteNotFoundError"];
    };
  };
  /**
   * List Favorite Groups
   * @description Return a list of favorite groups owned by a user. Returns the same information as `getFavoriteGroups`.
   */
  getFavoriteGroups: {
    parameters: {
      query?: {
        n?: components["parameters"]["number"];
        offset?: components["parameters"]["offset"];
        /** @description The owner of whoms favorite groups to return. Must be a UserID. */
        ownerId?: string;
      };
    };
    responses: {
      200: components["responses"]["FavoriteGroupListResponse"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Show Favorite Group
   * @description Fetch information about a specific favorite group.
   */
  getFavoriteGroup: {
    parameters: {
      path: {
        favoriteGroupType: components["parameters"]["favoriteGroupType"];
        favoriteGroupName: components["parameters"]["favoriteGroupName"];
        userId: components["parameters"]["userId"];
      };
    };
    responses: {
      200: components["responses"]["FavoriteGroupResponse"];
    };
  };
  /**
   * Update Favorite Group
   * @description Update information about a specific favorite group.
   */
  updateFavoriteGroup: {
    parameters: {
      path: {
        favoriteGroupType: components["parameters"]["favoriteGroupType"];
        favoriteGroupName: components["parameters"]["favoriteGroupName"];
        userId: components["parameters"]["userId"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["UpdateFavoriteGroupRequest"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: never;
      };
    };
  };
  /**
   * Clear Favorite Group
   * @description Clear ALL contents of a specific favorite group.
   */
  clearFavoriteGroup: {
    parameters: {
      path: {
        favoriteGroupType: components["parameters"]["favoriteGroupType"];
        favoriteGroupName: components["parameters"]["favoriteGroupName"];
        userId: components["parameters"]["userId"];
      };
    };
    responses: {
      200: components["responses"]["FavoriteGroupClearedSuccess"];
    };
  };
  /**
   * List Files
   * @description Returns a list of files
   */
  getFiles: {
    parameters: {
      query?: {
        /** @description Tag, for example "icon" or "gallery", not included by default. */
        tag?: string;
        /**
         * @deprecated
         * @description UserID, will always generate a 500 permission error.
         */
        userId?: string;
        n?: components["parameters"]["number"];
        offset?: components["parameters"]["offset"];
      };
    };
    responses: {
      200: components["responses"]["FileListResponse"];
    };
  };
  /**
   * Create File
   * @description Creates a new File object
   */
  createFile: {
    requestBody?: {
      content: {
        "application/json": components["schemas"]["CreateFileRequest"];
      };
    };
    responses: {
      200: components["responses"]["FileResponse"];
    };
  };
  /**
   * Show File
   * @description Shows general information about the "File" object. Each File can have several "Version"'s, and each Version can have multiple real files or "Data" blobs.
   */
  getFile: {
    parameters: {
      path: {
        fileId: components["parameters"]["fileId"];
      };
    };
    responses: {
      200: components["responses"]["FileResponse"];
      404: components["responses"]["FileNotFoundError"];
    };
  };
  /**
   * Create File Version
   * @description Creates a new FileVersion. Once a Version has been created, proceed to the `/file/{fileId}/{versionId}/file/start` endpoint to start a file upload.
   */
  createFileVersion: {
    parameters: {
      path: {
        fileId: components["parameters"]["fileId"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["CreateFileVersionRequest"];
      };
    };
    responses: {
      200: components["responses"]["FileResponse"];
    };
  };
  /**
   * Delete File
   * @description Deletes a File object.
   */
  deleteFile: {
    parameters: {
      path: {
        fileId: components["parameters"]["fileId"];
      };
    };
    responses: {
      200: components["responses"]["FileDeletedSuccess"];
      404: components["responses"]["FileDeletedError"];
    };
  };
  /**
   * Download File Version
   * @description Downloads the file with the provided version number.
   *
   * **Version Note:** Version 0 is always when the file was created. The real data is usually always located in version 1 and up.
   *
   * **Extension Note:** Files are not guaranteed to have a file extensions. UnityPackage files tends to have it, images through this endpoint do not. You are responsible for appending file extension from the `extension` field when neccesary.
   */
  downloadFileVersion: {
    parameters: {
      path: {
        fileId: components["parameters"]["fileId"];
        versionId: components["parameters"]["versionId"];
      };
    };
    responses: {
      200: components["responses"]["RawFileResponse"];
    };
  };
  /**
   * Delete File Version
   * @description Delete a specific version of a file. You can only delete the latest version.
   */
  deleteFileVersion: {
    parameters: {
      path: {
        fileId: components["parameters"]["fileId"];
        versionId: components["parameters"]["versionId"];
      };
    };
    responses: {
      200: components["responses"]["FileResponse"];
      400: components["responses"]["FileVersionDeleteInitialError"];
      500: components["responses"]["FileVersionDeleteMiddleError"];
    };
  };
  /**
   * Finish FileData Upload
   * @description Finish an upload of a FileData. This will mark it as "complete". After uploading the `file` for Avatars and Worlds you then have to upload a `signature` file.
   */
  finishFileDataUpload: {
    parameters: {
      path: {
        fileId: components["parameters"]["fileId"];
        versionId: components["parameters"]["versionId"];
        fileType: components["parameters"]["fileType"];
      };
    };
    /**
     * @description Please see documentation on ETag's:
     * [https://teppen.io/2018/06/23/aws_s3_etags/](https://teppen.io/2018/06/23/aws_s3_etags/)
     *
     * ETag's should NOT be present when uploading a `signature`.
     */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["FinishFileDataUploadRequest"];
      };
    };
    responses: {
      200: components["responses"]["FileResponse"];
    };
  };
  /**
   * Start FileData Upload
   * @description Starts an upload of a specific FilePart. This endpoint will return an AWS URL which you can PUT data to. You need to call this and receive a new AWS API URL for each `partNumber`. Please see AWS's REST documentation on "PUT Object to S3" on how to upload. Once all parts has been uploaded, proceed to `/finish` endpoint.
   *
   * **Note:** `nextPartNumber` seems like it is always ignored. Despite it returning 0, first partNumber is always 1.
   */
  startFileDataUpload: {
    parameters: {
      query?: {
        /**
         * @deprecated
         * @description The part number to start uploading. If not provided, the first part will be started.
         */
        partNumber?: number;
      };
      path: {
        fileId: components["parameters"]["fileId"];
        versionId: components["parameters"]["versionId"];
        fileType: components["parameters"]["fileType"];
      };
    };
    responses: {
      200: components["responses"]["FileUploadURLResponse"];
      400: components["responses"]["FileUploadAlreadyFinishedError"];
    };
  };
  /**
   * Check FileData Upload Status
   * @description Retrieves the upload status for file upload. Can currently only be accessed when `status` is `waiting`. Trying to access it on a file version already uploaded currently times out.
   */
  getFileDataUploadStatus: {
    parameters: {
      path: {
        fileId: components["parameters"]["fileId"];
        versionId: components["parameters"]["versionId"];
        fileType: components["parameters"]["fileType"];
      };
    };
    responses: {
      200: components["responses"]["FileVersionUploadStatusResponse"];
    };
  };
  /**
   * List Friends
   * @description List information about friends.
   */
  getFriends: {
    parameters: {
      query?: {
        offset?: components["parameters"]["offset"];
        n?: components["parameters"]["number"];
        offline?: components["parameters"]["offline"];
      };
    };
    responses: {
      200: components["responses"]["LimitedUserListResponse"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Send Friend Request
   * @description Send a friend request to another user.
   */
  friend: {
    parameters: {
      path: {
        userId: components["parameters"]["userId"];
      };
    };
    responses: {
      200: components["responses"]["NotificationResponse"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["UserDoesntExistError"];
    };
  };
  /**
   * Delete Friend Request
   * @description Deletes an outgoing pending friend request to another user. To delete an incoming friend request, use the `deleteNotification` endpoint instead.
   */
  deleteFriendRequest: {
    parameters: {
      path: {
        userId: components["parameters"]["userId"];
      };
    };
    responses: {
      200: components["responses"]["DeleteFriendSuccess"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["DeleteFriendRequestError"];
    };
  };
  /**
   * Check Friend Status
   * @description Retrieve if the user is currently a friend with a given user, if they have an outgoing friend request, and if they have an incoming friend request. The proper way to receive and accept friend request is by checking if the user has an incoming `Notification` of type `friendRequest`, and then accepting that notification.
   */
  getFriendStatus: {
    parameters: {
      path: {
        userId: components["parameters"]["userId"];
      };
    };
    responses: {
      200: components["responses"]["FriendStatusResponse"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Unfriend
   * @description Unfriend a user by ID.
   */
  unfriend: {
    parameters: {
      path: {
        userId: components["parameters"]["userId"];
      };
    };
    responses: {
      200: components["responses"]["UnfriendSuccess"];
      400: components["responses"]["NotFriendsError"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Create Group
   * @description Creates a Group and returns a Group object. **Requires VRC+ Subscription.**
   */
  createGroup: {
    requestBody?: {
      content: {
        "application/json": components["schemas"]["CreateGroupRequest"];
      };
    };
    responses: {
      200: components["responses"]["GroupResponse"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Get Group by ID
   * @description Returns a single Group by ID.
   */
  getGroup: {
    parameters: {
      query?: {
        /** @description Include roles for the Group object. Defaults to false. */
        includeRoles?: boolean;
      };
      path: {
        groupId: components["parameters"]["groupId"];
      };
    };
    responses: {
      200: components["responses"]["GroupResponse"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["GroupNotFoundError"];
    };
  };
  /**
   * Update Group
   * @description Updates a Group and returns it.
   */
  updateGroup: {
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["UpdateGroupRequest"];
      };
    };
    responses: {
      200: components["responses"]["GroupResponse"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["GroupNotFoundError"];
    };
  };
  /**
   * Delete Group
   * @description Deletes a Group.
   */
  deleteGroup: {
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
      };
    };
    responses: {
      200: components["responses"]["DeleteGroupSuccess"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["GroupNotFoundError"];
    };
  };
  /**
   * Get Group Announcement
   * @description Returns the announcement for a Group.
   * If no announcement has been made, then it returns **empty object**.
   * If an announcement exists, then it will always return all fields except `imageId` and `imageUrl` which may be null.
   */
  getGroupAnnouncements: {
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
      };
    };
    responses: {
      200: components["responses"]["GroupAnnouncementResponse"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["GroupNotFoundError"];
    };
  };
  /**
   * Create Group Announcement
   * @description Creates an Announcement for a Group.
   */
  createGroupAnnouncement: {
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["CreateGroupAnnouncementRequest"];
      };
    };
    responses: {
      200: components["responses"]["GroupAnnouncementResponse"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["GroupNotFoundError"];
    };
  };
  /**
   * Delete Group Announcement
   * @description Deletes the announcement for a Group.
   */
  deleteGroupAnnouncement: {
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
      };
    };
    responses: {
      200: components["responses"]["DeleteGroupAnnouncementSuccess"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["GroupNotFoundError"];
    };
  };
  /**
   * Get Group Audit Logs
   * @description Returns a list of audit logs for a Group.
   */
  getGroupAuditLogs: {
    parameters: {
      query?: {
        n?: components["parameters"]["number"];
        offset?: components["parameters"]["offset"];
        startDate?: components["parameters"]["startDate"];
        endDate?: components["parameters"]["endDate"];
      };
      path: {
        groupId: components["parameters"]["groupId"];
      };
    };
    responses: {
      200: components["responses"]["GroupAuditLogListResponse"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["GroupNotFoundError"];
    };
  };
  /**
   * Get Group Bans
   * @description Returns a list of banned users for a Group.
   */
  getGroupBans: {
    parameters: {
      query?: {
        n?: components["parameters"]["number"];
        offset?: components["parameters"]["offset"];
      };
      path: {
        groupId: components["parameters"]["groupId"];
      };
    };
    responses: {
      200: components["responses"]["GroupMemberListResponse"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["GroupNotFoundError"];
    };
  };
  /**
   * Ban Group Member
   * @description Bans a user from a Group.
   */
  banGroupMember: {
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["BanGroupMemberRequest"];
      };
    };
    responses: {
      200: components["responses"]["GroupMemberResponse"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["GroupNotFoundError"];
    };
  };
  /**
   * Unban Group Member
   * @description Unbans a user from a Group.
   */
  unbanGroupMember: {
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
        userId: components["parameters"]["userId"];
      };
    };
    responses: {
      200: components["responses"]["GroupMemberResponse"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["GroupNotFoundError"];
    };
  };
  /**
   * Create Group Gallery
   * @description Creates a gallery for a Group.
   */
  createGroupGallery: {
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["CreateGroupGalleryRequest"];
      };
    };
    responses: {
      200: components["responses"]["GroupGalleryResponse"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["GroupNotFoundError"];
    };
  };
  /**
   * Get Group Gallery Images
   * @description Returns a list of images for a Group gallery.
   */
  getGroupGalleryImages: {
    parameters: {
      query?: {
        n?: components["parameters"]["number"];
        offset?: components["parameters"]["offset"];
        /** @description If specified, only returns images that have been approved or not approved. */
        approved?: boolean;
      };
      path: {
        groupId: components["parameters"]["groupId"];
        groupGalleryId: components["parameters"]["groupGalleryId"];
      };
    };
    responses: {
      200: components["responses"]["GroupGalleryImageListResponse"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["GroupNotFoundError"];
    };
  };
  /**
   * Update Group Gallery
   * @description Updates a gallery for a Group.
   */
  updateGroupGallery: {
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
        groupGalleryId: components["parameters"]["groupGalleryId"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["UpdateGroupGalleryRequest"];
      };
    };
    responses: {
      200: components["responses"]["GroupGalleryResponse"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["GroupNotFoundError"];
    };
  };
  /**
   * Delete Group Gallery
   * @description Deletes a gallery for a Group.
   */
  deleteGroupGallery: {
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
        groupGalleryId: components["parameters"]["groupGalleryId"];
      };
    };
    responses: {
      200: components["responses"]["DeleteGroupGallerySuccess"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["GroupNotFoundError"];
    };
  };
  /**
   * Add Group Gallery Image
   * @description Adds an image to a Group gallery.
   */
  addGroupGalleryImage: {
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
        groupGalleryId: components["parameters"]["groupGalleryId"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["AddGroupGalleryImageRequest"];
      };
    };
    responses: {
      200: components["responses"]["GroupGalleryImageResponse"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["GroupNotFoundError"];
    };
  };
  /**
   * Delete Group Gallery Image
   * @description Deletes an image from a Group gallery.
   */
  deleteGroupGalleryImage: {
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
        groupGalleryId: components["parameters"]["groupGalleryId"];
        groupGalleryImageId: components["parameters"]["groupGalleryImageId"];
      };
    };
    responses: {
      200: components["responses"]["DeleteGroupGalleryImageSuccess"];
      401: components["responses"]["MissingCredentialsError"];
      403: components["responses"]["GroupGalleryImageDeleteForbiddenError"];
      404: components["responses"]["GroupNotFoundError"];
    };
  };
  /**
   * Get Group Invites Sent
   * @description Returns a list of members that have been invited to the Group.
   */
  getGroupInvites: {
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
      };
    };
    responses: {
      200: components["responses"]["GroupMemberListResponse"];
      401: components["responses"]["MissingCredentialsError"];
      403: components["responses"]["GroupNotMemberError"];
      404: components["responses"]["GroupNotFoundError"];
    };
  };
  /**
   * Invite User to Group
   * @description Sends an invite to a user to join the group.
   */
  createGroupInvite: {
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["CreateGroupInviteRequest"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: never;
      };
      /** @description User <displayName> is already invited */
      400: {
        content: never;
      };
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["GroupNotFoundError"];
    };
  };
  /**
   * Delete User Invite
   * @description Deletes an Group invite sent to a User
   */
  deleteGroupInvite: {
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
        userId: components["parameters"]["userId"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: never;
      };
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Join Group
   * @description Join a Group by ID and returns the member object.
   */
  joinGroup: {
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
      };
    };
    responses: {
      200: components["responses"]["GroupMemberResponse"];
      400: components["responses"]["GroupAlreadyMemberError"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["GroupNotFoundError"];
    };
  };
  /**
   * Leave Group
   * @description Leave a group by ID.
   */
  leaveGroup: {
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: never;
      };
      403: components["responses"]["GroupNotMemberError"];
      404: components["responses"]["GroupNotFoundError"];
    };
  };
  /**
   * List Group Members
   * @description Returns a List of all **other** Group Members. This endpoint will never return the user calling the endpoint.
   * Information about the user calling the endpoint must be found in the `myMember` field of the Group object.
   */
  getGroupMembers: {
    parameters: {
      query?: {
        n?: components["parameters"]["number"];
        offset?: components["parameters"]["offset"];
      };
      path: {
        groupId: components["parameters"]["groupId"];
      };
    };
    responses: {
      200: components["responses"]["GroupMemberListResponse"];
      400: components["responses"]["UsersInvalidSearchError"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["GroupNotFoundError"];
    };
  };
  /**
   * Get Group Member
   * @description Returns a LimitedGroup Member.
   */
  getGroupMember: {
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
        userId: components["parameters"]["userId"];
      };
    };
    responses: {
      200: components["responses"]["GroupLimitedMemberResponse"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["GroupNotFoundError"];
    };
  };
  /**
   * Update Group Member
   * @description Updates a Group Member
   */
  updateGroupMember: {
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
        userId: components["parameters"]["userId"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["UpdateGroupMemberRequest"];
      };
    };
    responses: {
      200: components["responses"]["GroupLimitedMemberResponse"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["GroupNotFoundError"];
    };
  };
  /**
   * Kick Group Member
   * @description Kicks a Group Member from the Group. The current user must have the "Remove Group Members" permission.
   */
  kickGroupMember: {
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
        userId: components["parameters"]["userId"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: never;
      };
      401: components["responses"]["MissingCredentialsError"];
      403: components["responses"]["GroupNotMemberError"];
      404: components["responses"]["GroupNotFoundError"];
    };
  };
  /**
   * Add Role to GroupMember
   * @description Adds a Role to a Group Member
   */
  addGroupMemberRole: {
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
        userId: components["parameters"]["userId"];
        groupRoleId: components["parameters"]["groupRoleId"];
      };
    };
    responses: {
      200: components["responses"]["GroupRoleIDListResponse"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["GroupNotFoundError"];
    };
  };
  /**
   * Remove Role from GroupMember
   * @description Removes a Role from a Group Member
   */
  removeGroupMemberRole: {
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
        userId: components["parameters"]["userId"];
        groupRoleId: components["parameters"]["groupRoleId"];
      };
    };
    responses: {
      200: components["responses"]["GroupRoleIDListResponse"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["GroupNotFoundError"];
    };
  };
  /**
   * List Group Permissions
   * @description Returns a List of all possible/available permissions for a Group.
   */
  getGroupPermissions: {
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
      };
    };
    responses: {
      200: components["responses"]["GroupPermissionListResponse"];
      400: components["responses"]["UsersInvalidSearchError"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["GroupNotFoundError"];
    };
  };
  /**
   * Get Group Join Requests
   * @description Returns a list of members that have requested to join the Group.
   */
  getGroupRequests: {
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
      };
    };
    responses: {
      200: components["responses"]["GroupMemberListResponse"];
      403: components["responses"]["GroupNotMemberError"];
      404: components["responses"]["GroupNotFoundError"];
    };
  };
  /**
   * Cancel Group Join Request
   * @description Cancels a request sent to join the group.
   */
  cancelGroupRequest: {
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: never;
      };
      /** @description You can't cancel a join request if you didn't request to join․ */
      400: {
        content: never;
      };
      403: components["responses"]["GroupNotMemberError"];
      404: components["responses"]["GroupNotFoundError"];
    };
  };
  /**
   * Respond Group Join request
   * @description Responds to a Group Join Request with Accept/Deny
   */
  respondGroupJoinRequest: {
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
        userId: components["parameters"]["userId"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["RespondGroupJoinRequest"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: never;
      };
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["GroupNotFoundError"];
    };
  };
  /**
   * Get Group Roles
   * @description Returns a Group Role by ID.
   */
  getGroupRoles: {
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
      };
    };
    responses: {
      200: components["responses"]["GroupRoleListResponse"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["GroupNotFoundError"];
    };
  };
  /**
   * Create GroupRole
   * @description Create a Group role.
   */
  createGroupRole: {
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["CreateGroupRoleRequest"];
      };
    };
    responses: {
      200: components["responses"]["GroupRoleResponse"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["GroupNotFoundError"];
    };
  };
  /**
   * Update Group Role
   * @description Updates a group role by ID.
   */
  updateGroupRole: {
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
        groupRoleId: components["parameters"]["groupRoleId"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["UpdateGroupRoleRequest"];
      };
    };
    responses: {
      200: components["responses"]["GroupRoleListResponse"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Delete Group Role
   * @description Deletes a Group Role by ID and returns the remaining roles.
   */
  deleteGroupRole: {
    parameters: {
      path: {
        groupId: components["parameters"]["groupId"];
        groupRoleId: components["parameters"]["groupRoleId"];
      };
    };
    responses: {
      200: components["responses"]["GroupRoleListResponse"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["GroupNotMemberError"];
    };
  };
  /**
   * Invite User
   * @description Sends an invite to a user. Returns the Notification of type `invite` that was sent.
   */
  inviteUser: {
    parameters: {
      path: {
        userId: components["parameters"]["userId"];
      };
    };
    /** @description Slot number of the Invite Message to use when inviting a user. */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["InviteRequest"];
      };
    };
    responses: {
      200: components["responses"]["SendNotificationResponse"];
      403: components["responses"]["InviteMustBeFriendsError"];
    };
  };
  /**
   * Invite Myself To Instance
   * @description Sends self an invite to an instance
   */
  inviteMyselfTo: {
    parameters: {
      path: {
        worldId: components["parameters"]["worldId"];
        instanceId: components["parameters"]["instanceId"];
      };
    };
    responses: {
      200: components["responses"]["SendNotificationResponse"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["InstanceNotFoundError"];
    };
  };
  /**
   * Request Invite
   * @description Requests an invite from a user. Returns the Notification of type `requestInvite` that was sent.
   */
  requestInvite: {
    parameters: {
      path: {
        userId: components["parameters"]["userId"];
      };
    };
    /** @description Slot number of the Request Message to use when request an invite. */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["RequestInviteRequest"];
      };
    };
    responses: {
      200: components["responses"]["NotificationResponse"];
      403: components["responses"]["InviteMustBeFriendsError"];
    };
  };
  /**
   * Respond Invite
   * @description Respond to an invite request by sending a world invite to the requesting user. `:notificationId` is the ID of the requesting notification.
   */
  respondInvite: {
    parameters: {
      path: {
        notificationId: components["parameters"]["notificationId"];
      };
    };
    /** @description Slot number of the Response Message to use when responding to a user. */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["InviteResponse"];
      };
    };
    responses: {
      200: components["responses"]["NotificationResponse"];
      400: components["responses"]["InviteResponse400Error"];
    };
  };
  /**
   * List Invite Messages
   * @description Returns a list of all the users Invite Messages. Admin Credentials are required to view messages of other users!
   *
   * Message type refers to a different collection of messages, used during different types of responses.
   *
   * * `message` = Message during a normal invite
   * * `response` = Message when replying to a message
   * * `request` = Message when requesting an invite
   * * `requestResponse` = Message when replying to a request for invite
   */
  getInviteMessages: {
    parameters: {
      path: {
        userId: components["parameters"]["userId"];
        messageType: components["parameters"]["messageType"];
      };
    };
    responses: {
      200: components["responses"]["InviteMessageListResponse"];
      400: components["responses"]["InviteMessageInvalidSlotNumberError"];
      401: components["responses"]["NotAuthorizedActionError"];
    };
  };
  /**
   * Get Invite Message
   * @description Returns a single Invite Message. This returns the exact same information but less than `getInviteMessages`. Admin Credentials are required to view messages of other users!
   *
   * Message type refers to a different collection of messages, used during different types of responses.
   *
   * * `message` = Message during a normal invite
   * * `response` = Message when replying to a message
   * * `request` = Message when requesting an invite
   * * `requestResponse` = Message when replying to a request for invite
   */
  getInviteMessage: {
    parameters: {
      path: {
        userId: components["parameters"]["userId"];
        messageType: components["parameters"]["messageType"];
        slot: components["parameters"]["slot"];
      };
    };
    responses: {
      200: components["responses"]["InviteMessageResponse"];
      400: components["responses"]["InviteMessageGetNegativeSlotError"];
      401: components["responses"]["NotAuthorizedActionError"];
      404: components["responses"]["InviteMessageGetTooHighSlotError"];
    };
  };
  /**
   * Update Invite Message
   * @description Updates a single Invite Message and then returns a list of all of them. Admin Credentials are required to update messages of other users!
   *
   * Updating a message automatically sets the cooldown timer to 60 minutes.
   * Trying to edit a message before the cooldown timer expires results in a 429 "Too Fast Error".
   *
   * Message type refers to a different collection of messages, used during different types of responses.
   *
   * * `message` = Message during a normal invite
   * * `response` = Message when replying to a message
   * * `request` = Message when requesting an invite
   * * `requestResponse` = Message when replying to a request for invite
   */
  updateInviteMessage: {
    parameters: {
      path: {
        userId: components["parameters"]["userId"];
        messageType: components["parameters"]["messageType"];
        slot: components["parameters"]["slot"];
      };
    };
    /** @description Message of what to set the invite message to. */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["UpdateInviteMessageRequest"];
      };
    };
    responses: {
      200: components["responses"]["InviteMessageListResponse"];
      400: components["responses"]["InviteMessageInvalidSlotNumberError"];
      401: components["responses"]["NotAuthorizedActionError"];
      429: components["responses"]["InviteMessageUpdateRateLimitError"];
    };
  };
  /**
   * Reset Invite Message
   * @description Resets a single Invite Message back to its original message, and then returns a list of all of them. Admin Credentials are required to update messages of other users!
   *
   * Resetting a message respects the rate-limit, so it is not possible to reset within the 60 minutes countdown.
   * Resetting it does however not set the rate-limit to 60 like when editing it.
   * It is possible to edit it right after resetting it.
   * Trying to edit a message before the cooldown timer expires results in a 429 "Too Fast Error".
   *
   * Message type refers to a different collection of messages, used during different types of responses.
   *
   * * `message` = Message during a normal invite
   * * `response` = Message when replying to a message
   * * `request` = Message when requesting an invite
   * * `requestResponse` = Message when replying to a request for invite
   *
   * The DELETE endpoint does not have/require any request body.
   */
  resetInviteMessage: {
    parameters: {
      path: {
        userId: components["parameters"]["userId"];
        messageType: components["parameters"]["messageType"];
        slot: components["parameters"]["slot"];
      };
    };
    responses: {
      200: components["responses"]["InviteMessageListResponse"];
      400: components["responses"]["InviteMessageInvalidSlotNumberError"];
      401: components["responses"]["NotAuthorizedActionError"];
      404: components["responses"]["InviteMessageNoEntryForSlotError"];
      429: components["responses"]["InviteMessageUpdateRateLimitError"];
    };
  };
  /**
   * Get Instance
   * @description Returns an instance. Please read [Instances Tutorial](https://vrchatapi.github.io/tutorials/instances/) for more information on Instances.
   *
   * If an invalid instanceId is provided, this endpoint will simply return "null"!
   */
  getInstance: {
    parameters: {
      path: {
        worldId: components["parameters"]["worldId"];
        instanceId: components["parameters"]["instanceId"];
      };
    };
    responses: {
      200: components["responses"]["InstanceResponse"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Get Instance Short Name
   * @description Returns an instance short name.
   */
  getShortName: {
    parameters: {
      path: {
        worldId: components["parameters"]["worldId"];
        instanceId: components["parameters"]["instanceId"];
      };
    };
    responses: {
      200: components["responses"]["InstanceShortNameResponse"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Send Self Invite
   * @description Sends an invite to the instance to yourself.
   */
  sendSelfInvite: {
    parameters: {
      path: {
        worldId: components["parameters"]["worldId"];
        instanceId: components["parameters"]["instanceId"];
      };
    };
    responses: {
      200: components["responses"]["InstanceSelfInviteSuccess"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Get Instance By Short Name
   * @description Returns an instance. Please read [Instances Tutorial](https://vrchatapi.github.io/tutorials/instances/) for more information on Instances.
   */
  getInstanceByShortName: {
    parameters: {
      path: {
        /** @description Must be a valid instance short name. */
        shortName: string;
      };
    };
    responses: {
      200: components["responses"]["InstanceResponse"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["InstanceNotFoundError"];
    };
  };
  /**
   * List Notifications
   * @description Retrieve all of the current user's notifications.
   */
  getNotifications: {
    parameters: {
      query?: {
        /**
         * @deprecated
         * @description Only send notifications of this type (can use `all` for all). This parameter no longer does anything, and is deprecated.
         */
        type?: string;
        /**
         * @deprecated
         * @description Return notifications sent by the user. Must be false or omitted.
         */
        sent?: boolean;
        /** @description Whether to return hidden or non-hidden notifications. True only allowed on type `friendRequest`. */
        hidden?: boolean;
        /** @description Only return notifications sent after this Date. Ignored if type is `friendRequest`. */
        after?: string;
        n?: components["parameters"]["number"];
        offset?: components["parameters"]["offset"];
      };
    };
    responses: {
      200: components["responses"]["NotificationListResponse"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Accept Friend Request
   * @description Accept a friend request by notification `frq_` ID. Friend requests can be found using the NotificationsAPI `getNotifications` by filtering of type `friendRequest`.
   */
  acceptFriendRequest: {
    parameters: {
      path: {
        notificationId: components["parameters"]["notificationId"];
      };
    };
    responses: {
      200: components["responses"]["FriendSuccess"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["AcceptFriendRequestError"];
    };
  };
  /**
   * Mark Notification As Read
   * @description Mark a notification as seen.
   */
  markNotificationAsRead: {
    parameters: {
      path: {
        notificationId: components["parameters"]["notificationId"];
      };
    };
    responses: {
      200: components["responses"]["NotificationResponse"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Delete Notification
   * @description Delete a notification.
   */
  deleteNotification: {
    parameters: {
      path: {
        notificationId: components["parameters"]["notificationId"];
      };
    };
    responses: {
      200: components["responses"]["NotificationResponse"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Clear All Notifications
   * @description Clear **all** notifications.
   */
  clearNotifications: {
    responses: {
      200: components["responses"]["ClearNotificationsSuccess"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Get Assigned Permissions
   * @description Returns a list of all permissions currently granted by the user. Permissions are assigned e.g. by subscribing to VRC+.
   */
  getAssignedPermissions: {
    responses: {
      200: components["responses"]["PermissionListResponse"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Get Permission
   * @description Returns a single permission. This endpoint is pretty useless, as it returns the exact same information as `/auth/permissions`.
   */
  getPermission: {
    parameters: {
      path: {
        permissionId: components["parameters"]["permissionId"];
      };
    };
    responses: {
      200: components["responses"]["PermissionResponse"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Search Player Moderations
   * @description Returns a list of all player moderations made by **you**.
   *
   * This endpoint does not have pagination, and will return *all* results. Use query parameters to limit your query if needed.
   */
  getPlayerModerations: {
    parameters: {
      query?: {
        /** @description Must be one of PlayerModerationType, except unblock. Unblocking simply removes a block. */
        type?: string;
        /** @description Must be valid UserID. */
        targetUserId?: string;
      };
    };
    responses: {
      200: components["responses"]["PlayerModerationListResponse"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Moderate User
   * @description Moderate a user, e.g. unmute them or show their avatar.
   *
   * Please see the [Player Moderation docs](https://vrchatapi.github.io/docs/api/#tag--playermoderation) on what playerModerations are, and how they differ from staff moderations.
   */
  moderateUser: {
    requestBody?: {
      content: {
        "application/json": components["schemas"]["ModerateUserRequest"];
      };
    };
    responses: {
      200: components["responses"]["PlayerModerationResponse"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Clear All Player Moderations
   * @description ⚠️ **This will delete every single player moderation you've ever made.**
   */
  clearAllPlayerModerations: {
    responses: {
      200: components["responses"]["PlayerModerationClearAllSuccess"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Get Player Moderation
   * @description Returns a single Player Moderation. This returns the exact same amount of information as the more generalised `getPlayerModerations`.
   */
  getPlayerModeration: {
    parameters: {
      path: {
        /** @description Must be a valid `pmod_` ID. */
        playerModerationId: string;
      };
    };
    responses: {
      200: components["responses"]["PlayerModerationResponse"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["PlayerModerationNotFoundError"];
    };
  };
  /**
   * Delete Player Moderation
   * @description Deletes a specific player moderation based on it's `pmod_` ID. The website uses `unmoderateUser` instead. You can delete the same player moderation multiple times successfully.
   */
  deletePlayerModeration: {
    parameters: {
      path: {
        /** @description Must be a valid `pmod_` ID. */
        playerModerationId: string;
      };
    };
    responses: {
      200: components["responses"]["PlayerModerationRemovedSuccess"];
      401: components["responses"]["MissingCredentialsError"];
      403: components["responses"]["PlayerModerationDeleteOthersError"];
    };
  };
  /**
   * Unmoderate User
   * @description Removes a player moderation previously added through `moderateUser`. E.g if you previously have shown their avatar, but now want to reset it to default.
   */
  unmoderateUser: {
    requestBody?: {
      content: {
        "application/json": components["schemas"]["ModerateUserRequest"];
      };
    };
    responses: {
      200: components["responses"]["PlayerModerationUnmoderatedSuccess"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Fetch API Config
   * @description API config contains configuration that the clients needs to work properly.
   *
   * Currently the most important value here is `clientApiKey` which is used for all other API endpoints.
   */
  getConfig: {
    responses: {
      200: components["responses"]["APIConfigResponse"];
    };
  };
  /**
   * Show Information Notices
   * @description IPS (Info Push System) is a system for VRChat to push out dynamic information to the client. This is primarily used by the Quick-Menu info banners, but can also be used to e.g. alert you to update your game to the latest version.
   *
   * `include` is used to query what Information Pushes should be included in the response. If include is missing or empty, then no notices will normally be returned. This is an "any of" search.
   *
   * `require` is used to limit what Information Pushes should be included in the response. This is usually used in combination with `include`, and is an "all of" search.
   */
  getInfoPush: {
    parameters: {
      query?: {
        require?: components["parameters"]["require"];
        include?: components["parameters"]["include"];
      };
    };
    responses: {
      200: components["responses"]["InfoPushListResponse"];
    };
  };
  /**
   * Download CSS
   * @description Fetches the CSS code to the frontend React website.
   */
  getCSS: {
    parameters: {
      query?: {
        variant?: components["parameters"]["variant"];
        branch?: components["parameters"]["branch"];
      };
    };
    responses: {
      /** @description **Note:** VRChat uses 302 Redirect to Cloudfront. The implementing library **must** support and follow redirects natively. */
      200: {
        content: {
          "text/css": string;
        };
      };
      400: components["responses"]["DownloadSourceCodeAccessError"];
    };
  };
  /**
   * Download JavaScript
   * @description Fetches the JavaScript code to the frontend React website.
   */
  getJavaScript: {
    parameters: {
      query?: {
        variant?: components["parameters"]["variant"];
        branch?: components["parameters"]["branch"];
      };
    };
    responses: {
      /** @description **Note:** VRChat uses 302 Redirect to Cloudfront. The implementing library **must** support and follow redirects natively. */
      200: {
        content: {
          "application/javascript": string;
        };
      };
      400: components["responses"]["DownloadSourceCodeAccessError"];
    };
  };
  /**
   * Check API Health
   * @deprecated
   * @description ~~Gets the overall health status, the server name, and the current build version tag of the API.~~
   *
   * **DEPRECATED:** VRChat has suddenly restricted this endpoint for unknown reasons, and now always return 401 Unauthorized.
   */
  getHealth: {
    responses: {
      200: components["responses"]["APIHealthResponse"];
    };
  };
  /**
   * Current Online Users
   * @description Returns the current number of online users.
   *
   * **NOTE:** The response type is not a JSON object, but a simple JSON integer.
   */
  getCurrentOnlineUsers: {
    responses: {
      200: components["responses"]["CurrentOnlineUsersResponse"];
    };
  };
  /**
   * Current System Time
   * @description Returns the current time of the API server.
   *
   * **NOTE:** The response type is not a JSON object, but a simple JSON string.
   */
  getSystemTime: {
    responses: {
      200: components["responses"]["SystemTimeResponse"];
    };
  };
  /**
   * Search All Users
   * @description Search and list any users by text query
   */
  searchUsers: {
    parameters: {
      query?: {
        /** @description Searches by `displayName`. Will return empty array if search query is empty or missing. */
        search?: string;
        /** @description Active user by developer type, none for normal users and internal for moderators */
        developerType?: string;
        n?: components["parameters"]["number"];
        offset?: components["parameters"]["offset"];
      };
    };
    responses: {
      200: components["responses"]["LimitedUserListResponse"];
      400: components["responses"]["UsersInvalidSearchError"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Get User by Username
   * @deprecated
   * @description ~~Get public user information about a specific user using their name.~~
   *
   * **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429).
   * This endpoint now require Admin Credentials.
   */
  getUserByName: {
    parameters: {
      path: {
        /** @description Username of the user */
        username: string;
      };
    };
    responses: {
      200: components["responses"]["UserResponse"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Get User by ID
   * @description Get public user information about a specific user using their ID.
   */
  getUser: {
    parameters: {
      path: {
        userId: components["parameters"]["userId"];
      };
    };
    responses: {
      200: components["responses"]["UserResponse"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Update User Info
   * @description Update a users information such as the email and birthday.
   */
  updateUser: {
    parameters: {
      path: {
        userId: components["parameters"]["userId"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["UpdateUserRequest"];
      };
    };
    responses: {
      200: components["responses"]["CurrentUserResponse"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Get User Groups
   * @description Get user's public groups
   */
  getUserGroups: {
    parameters: {
      path: {
        userId: components["parameters"]["userId"];
      };
    };
    responses: {
      200: components["responses"]["GroupListResponse"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Get User Group Requests
   * @description Returns a list of Groups the user has requested to be invited into.
   */
  getUserGroupRequests: {
    parameters: {
      path: {
        userId: components["parameters"]["userId"];
      };
    };
    responses: {
      200: components["responses"]["GroupListResponse"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Search All Worlds
   * @description Search and list any worlds by query filters.
   */
  searchWorlds: {
    parameters: {
      query?: {
        featured?: components["parameters"]["featured"];
        sort?: components["parameters"]["sort"];
        /** @description Set to `me` for searching own worlds. */
        user?: "me";
        userId?: components["parameters"]["userIdQuery"];
        n?: components["parameters"]["number"];
        order?: components["parameters"]["order"];
        offset?: components["parameters"]["offset"];
        search?: components["parameters"]["search"];
        tag?: components["parameters"]["tag"];
        notag?: components["parameters"]["notag"];
        releaseStatus?: components["parameters"]["releaseStatus"];
        maxUnityVersion?: components["parameters"]["maxUnityVersion"];
        minUnityVersion?: components["parameters"]["minUnityVersion"];
        platform?: components["parameters"]["platform"];
      };
    };
    responses: {
      200: components["responses"]["LimitedWorldListResponse"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * Create World
   * @description Create a new world. This endpoint requires `assetUrl` to be a valid File object with `.vrcw` file extension, and `imageUrl` to be a valid File object with an image file extension.
   */
  createWorld: {
    requestBody?: {
      content: {
        "application/json": components["schemas"]["CreateWorldRequest"];
      };
    };
    responses: {
      200: components["responses"]["WorldResponse"];
      400: components["responses"]["WorldCreateNotAllowedYetError"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * List Active Worlds
   * @description Search and list currently Active worlds by query filters.
   */
  getActiveWorlds: {
    parameters: {
      query?: {
        featured?: components["parameters"]["featured"];
        sort?: components["parameters"]["sort"];
        n?: components["parameters"]["number"];
        order?: components["parameters"]["order"];
        offset?: components["parameters"]["offset"];
        search?: components["parameters"]["search"];
        tag?: components["parameters"]["tag"];
        notag?: components["parameters"]["notag"];
        releaseStatus?: components["parameters"]["releaseStatus"];
        maxUnityVersion?: components["parameters"]["maxUnityVersion"];
        minUnityVersion?: components["parameters"]["minUnityVersion"];
        platform?: components["parameters"]["platform"];
      };
    };
    responses: {
      200: components["responses"]["LimitedWorldListResponse"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
  /**
   * List Favorited Worlds
   * @description Search and list favorited worlds by query filters.
   */
  getFavoritedWorlds: {
    parameters: {
      query?: {
        featured?: components["parameters"]["featured"];
        sort?: components["parameters"]["sort"];
        n?: components["parameters"]["number"];
        order?: components["parameters"]["order"];
        offset?: components["parameters"]["offset"];
        search?: components["parameters"]["search"];
        tag?: components["parameters"]["tag"];
        notag?: components["parameters"]["notag"];
        releaseStatus?: components["parameters"]["releaseStatus"];
        maxUnityVersion?: components["parameters"]["maxUnityVersion"];
        minUnityVersion?: components["parameters"]["minUnityVersion"];
        platform?: components["parameters"]["platform"];
        userId?: components["parameters"]["userIdAdmin"];
      };
    };
    responses: {
      200: components["responses"]["LimitedWorldListResponse"];
      401: components["responses"]["MissingCredentialsError"];
      403: components["responses"]["WorldSeeOtherUserFavoritesError"];
    };
  };
  /**
   * List Recent Worlds
   * @description Search and list recently visited worlds by query filters.
   */
  getRecentWorlds: {
    parameters: {
      query?: {
        featured?: components["parameters"]["featured"];
        sort?: components["parameters"]["sort"];
        n?: components["parameters"]["number"];
        order?: components["parameters"]["order"];
        offset?: components["parameters"]["offset"];
        search?: components["parameters"]["search"];
        tag?: components["parameters"]["tag"];
        notag?: components["parameters"]["notag"];
        releaseStatus?: components["parameters"]["releaseStatus"];
        maxUnityVersion?: components["parameters"]["maxUnityVersion"];
        minUnityVersion?: components["parameters"]["minUnityVersion"];
        platform?: components["parameters"]["platform"];
        userId?: components["parameters"]["userIdAdmin"];
      };
    };
    responses: {
      200: components["responses"]["LimitedWorldListResponse"];
      401: components["responses"]["MissingCredentialsError"];
      403: components["responses"]["WorldSeeOtherUserRecentsError"];
    };
  };
  /**
   * Get World by ID
   * @description Get information about a specific World.
   * Works unauthenticated but when so will always return `0` for certain fields.
   */
  getWorld: {
    parameters: {
      path: {
        worldId: components["parameters"]["worldId"];
      };
    };
    responses: {
      200: components["responses"]["WorldResponse"];
      404: components["responses"]["WorldNotFoundError"];
    };
  };
  /**
   * Update World
   * @description Update information about a specific World.
   */
  updateWorld: {
    parameters: {
      path: {
        worldId: components["parameters"]["worldId"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["UpdateWorldRequest"];
      };
    };
    responses: {
      200: components["responses"]["WorldResponse"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["WorldNotFoundError"];
    };
  };
  /**
   * Delete World
   * @description Delete a world. Notice a world is never fully "deleted", only its ReleaseStatus is set to "hidden" and the linked Files are deleted. The WorldID is permanently reserved.
   */
  deleteWorld: {
    parameters: {
      path: {
        worldId: components["parameters"]["worldId"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: never;
      };
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["WorldNotFoundError"];
    };
  };
  /**
   * Get World Metadata
   * @deprecated
   * @description Return a worlds custom metadata. This is currently believed to be unused. Metadata can be set with `updateWorld` and can be any arbitrary object.
   */
  getWorldMetadata: {
    parameters: {
      path: {
        worldId: components["parameters"]["worldId"];
      };
    };
    responses: {
      200: components["responses"]["WorldMetadataResponse"];
      404: components["responses"]["WorldNotFoundError"];
    };
  };
  /**
   * Get World Publish Status
   * @description Returns a worlds publish status.
   */
  getWorldPublishStatus: {
    parameters: {
      path: {
        worldId: components["parameters"]["worldId"];
      };
    };
    responses: {
      200: components["responses"]["WorldPublishStatusResponse"];
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["WorldNotFoundError"];
    };
  };
  /**
   * Publish World
   * @description Publish a world. You can only publish one world per week.
   */
  publishWorld: {
    parameters: {
      path: {
        worldId: components["parameters"]["worldId"];
      };
    };
    responses: {
      /** @description TODO */
      200: {
        content: never;
      };
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["WorldNotFoundError"];
    };
  };
  /**
   * Unpublish World
   * @description Unpublish a world.
   */
  unpublishWorld: {
    parameters: {
      path: {
        worldId: components["parameters"]["worldId"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: never;
      };
      401: components["responses"]["MissingCredentialsError"];
      404: components["responses"]["WorldNotFoundError"];
    };
  };
  /**
   * Get World Instance
   * @description Returns a worlds instance.
   */
  getWorldInstance: {
    parameters: {
      path: {
        worldId: components["parameters"]["worldId"];
        instanceId: components["parameters"]["instanceId"];
      };
    };
    responses: {
      200: components["responses"]["InstanceResponse"];
      401: components["responses"]["MissingCredentialsError"];
    };
  };
}
